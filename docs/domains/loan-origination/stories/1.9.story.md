# Story 1.9: Comprehensive Audit Event Publishing to AdminService

Status: Draft

## Story

**As a** compliance auditor,  
**I want** all loan state changes published as audit events to AdminService,  
**so that** I have centralized, immutable audit trails for regulatory reporting.

## Acceptance Criteria

1. `AuditEventPublisher` service implemented with `PublishEventAsync<T>(event)` generic method
2. Publisher uses MassTransit `IPublishEndpoint` to publish to RabbitMQ exchange `intellifin.loan.events`
3. Event records defined for: LoanApplicationCreated, LoanApplicationSubmitted, LoanCreditAssessmentCompleted, LoanApprovalGranted, LoanApprovalRejected, LoanAgreementGenerated, LoanDisbursed, LoanVersionCreated, LoanWorkflowStateChanged
4. All events include CorrelationId (from `ICorrelationIdProvider`) for distributed tracing
5. `LoanApplicationService.CreateApplicationAsync` publishes LoanApplicationCreated on every new loan
6. Approval workers publish LoanApprovalGranted/Rejected events based on workflow outcome
7. Agreement worker publishes LoanAgreementGenerated event (already implemented in Story 1.8)
8. RabbitMQ exchange configured with durable queues, dead-letter exchange for failed deliveries
9. Integration test publishes events, verifies RabbitMQ receives them (Testcontainers)

## Integration Verification

- **IV1**: Create loan via API → verify LoanApplicationCreated event in RabbitMQ queue with correct payload
- **IV2**: Complete loan workflow end-to-end (create → assess → approve → generate agreement) → verify all 6+ events published in correct sequence with correlation IDs
- **IV3**: Simulate AdminService consumer failure → verify events route to dead-letter queue (at-least-once delivery guarantee)

## Dev Notes

### Previous Story Insights
- Story 1.2 implemented LoanVersioningService with version tracking
- Story 1.3 integrated Vault for product configurations
- Story 1.6 implemented event-driven KYC revocation handling (demonstrated MassTransit event publishing)
- Story 1.7 implemented DualControlValidator publishing `LoanApprovalAttempted` events
- Story 1.8 implemented AgreementGenerationService publishing `LoanAgreementGenerated` events
- Existing MassTransit configuration already registered in Program.cs [Source: brownfield-architecture.md#✅ Service Scaffolding and Infrastructure, lines 215-218]

### Current State Problem [Sources]

**Missing Comprehensive Audit Trail** - No event publishing for state changes
- Architecture document identifies this as critical gap [Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events to AdminService, lines 872-1027]
- Current state: No audit trail for loan state changes [Source: prd.md#1.2 What is MISSING, line 48]
- No centralized event stream to AdminService [Source: brownfield-architecture.md#Current State Analysis]
- No correlation IDs for distributed tracing [Source: brownfield-architecture.md#5. No Correlation ID Propagation, lines 1467-1473]

**Regulatory Requirement**: Bank of Zambia requires complete audit trails for all loan state changes with immutable records [Source: prd.md#1.4 Background Context; prd.md#FR9]

**Business Impact**: Inability to trace loan lifecycle events makes regulatory reporting and compliance audits extremely difficult [Source: prd.md#1.4 Goals - stream comprehensive audit events]

### AuditEventPublisher Implementation [Sources]

**Service Pattern**:
```csharp
public class AuditEventPublisher : IAuditEventPublisher
{
    private readonly IPublishEndpoint _publishEndpoint;
    private readonly ICorrelationIdProvider _correlationIdProvider;
    private readonly ILogger<AuditEventPublisher> _logger;
    
    public async Task PublishEventAsync<T>(T auditEvent, CancellationToken cancellationToken) 
        where T : class
    {
        _logger.LogInformation(
            "Publishing audit event {EventType}",
            typeof(T).Name);
        
        // Get or generate correlation ID for distributed tracing
        var correlationId = _correlationIdProvider.GetCorrelationId();
        
        // If event supports correlation ID, set it
        if (auditEvent is ICorrelatedEvent correlatedEvent && 
            string.IsNullOrEmpty(correlatedEvent.CorrelationId))
        {
            correlatedEvent.CorrelationId = correlationId;
        }
        
        // Publish to RabbitMQ exchange → AdminService consumes
        await _publishEndpoint.Publish(auditEvent, ctx =>
        {
            // Set message headers for tracing
            ctx.Headers.Set("CorrelationId", correlationId);
            ctx.Headers.Set("PublishedAt", DateTime.UtcNow.ToString("o"));
            ctx.Headers.Set("ServiceName", "LoanOriginationService");
        }, cancellationToken);
        
        _logger.LogInformation(
            "Published audit event {EventType}, CorrelationId: {CorrelationId}",
            typeof(T).Name, correlationId);
    }
    
    public async Task PublishEventsAsync<T>(IEnumerable<T> auditEvents, CancellationToken cancellationToken) 
        where T : class
    {
        var tasks = auditEvents.Select(evt => PublishEventAsync(evt, cancellationToken));
        await Task.WhenAll(tasks);
    }
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events to AdminService, lines 974-996 - pattern adapted with correlation ID and headers]

### Event Records [Sources]

**LoanApplicationCreated**:
```csharp
public record LoanApplicationCreated
{
    public Guid ApplicationId { get; init; }
    public string LoanNumber { get; init; }
    public Guid ClientId { get; init; }
    public string ProductCode { get; init; }
    public decimal Amount { get; init; }
    public int TermMonths { get; init; }
    public Guid CreatedBy { get; init; }
    public DateTime Timestamp { get; init; }
    public string CorrelationId { get; init; }
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 883-892]

**LoanApplicationSubmitted**:
```csharp
public record LoanApplicationSubmitted
{
    public Guid ApplicationId { get; init; }
    public string LoanNumber { get; init; }
    public Guid SubmittedBy { get; init; }
    public DateTime Timestamp { get; init; }
    public string CorrelationId { get; init; }
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 894-899]

**LoanCreditAssessmentCompleted**:
```csharp
public record LoanCreditAssessmentCompleted
{
    public Guid ApplicationId { get; init; }
    public string LoanNumber { get; init; }
    public string RiskGrade { get; init; } // A, B, C, D, F
    public decimal CreditScore { get; init; }
    public bool RecommendedForApproval { get; init; }
    public Guid AssessedBy { get; init; }
    public DateTime Timestamp { get; init; }
    public string CorrelationId { get; init; }
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 901-909]

**LoanApprovalGranted**:
```csharp
public record LoanApprovalGranted
{
    public Guid ApplicationId { get; init; }
    public string LoanNumber { get; init; }
    public Guid ApprovedBy { get; init; }
    public string ApproverRole { get; init; }
    public decimal ApprovedAmount { get; init; }
    public int ApprovedTerm { get; init; }
    public string ApprovalLevel { get; init; } // "CreditAnalyst", "HeadOfCredit", "CEO"
    public bool IsDualControlSecondApproval { get; init; }
    public DateTime Timestamp { get; init; }
    public string CorrelationId { get; init; }
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 911-921]

**LoanApprovalRejected**:
```csharp
public record LoanApprovalRejected
{
    public Guid ApplicationId { get; init; }
    public string LoanNumber { get; init; }
    public Guid RejectedBy { get; init; }
    public string RejectionReason { get; init; }
    public string RiskGrade { get; init; }
    public DateTime Timestamp { get; init; }
    public string CorrelationId { get; init; }
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 923-930]

**LoanAgreementGenerated** (already created in Story 1.8):
```csharp
public record LoanAgreementGenerated
{
    public Guid ApplicationId { get; init; }
    public string LoanNumber { get; init; }
    public Guid ClientId { get; init; }
    public string DocumentHash { get; init; }
    public string MinioPath { get; init; }
    public string TemplateVersion { get; init; }
    public Guid GeneratedBy { get; init; }
    public DateTime Timestamp { get; init; }
    public string CorrelationId { get; init; }
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 932-940; Story 1.8]

**LoanDisbursed**:
```csharp
public record LoanDisbursed
{
    public Guid ApplicationId { get; init; }
    public string LoanNumber { get; init; }
    public decimal DisbursedAmount { get; init; }
    public string PaymentMethod { get; init; }
    public string TransactionReference { get; init; }
    public Guid AuthorizedBy { get; init; }
    public DateTime Timestamp { get; init; }
    public string CorrelationId { get; init; }
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 942-950]

**LoanVersionCreated**:
```csharp
public record LoanVersionCreated
{
    public string LoanNumber { get; init; }
    public int PreviousVersion { get; init; }
    public int NewVersion { get; init; }
    public string ModificationReason { get; init; }
    public List<string> ChangedFields { get; init; }
    public Guid ModifiedBy { get; init; }
    public DateTime Timestamp { get; init; }
    public string CorrelationId { get; init; }
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 952-960]

**LoanWorkflowStateChanged**:
```csharp
public record LoanWorkflowStateChanged
{
    public Guid ApplicationId { get; init; }
    public string LoanNumber { get; init; }
    public string PreviousState { get; init; }
    public string NewState { get; init; }
    public string WorkflowInstanceKey { get; init; }
    public DateTime Timestamp { get; init; }
    public string CorrelationId { get; init; }
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 962-969]

### ICorrelatedEvent Interface [Sources]

**Marker Interface for Events with Correlation IDs**:
```csharp
public interface ICorrelatedEvent
{
    string CorrelationId { get; set; }
}
```

All audit event records should implement this interface to enable automatic correlation ID injection.

### Integration Points [Sources]

**LoanApplicationService.CreateApplicationAsync** (AC: 5):
```csharp
public async Task<LoanApplicationResponse> CreateApplicationAsync(
    CreateLoanApplicationRequest request,
    CancellationToken cancellationToken)
{
    // ... validation, KYC check, etc.
    
    var application = new LoanApplication
    {
        Id = Guid.NewGuid(),
        LoanNumber = await _versioningService.GenerateLoanNumberAsync("LUS"),
        ClientId = request.ClientId,
        ProductCode = request.ProductCode,
        RequestedAmount = request.Amount,
        TermMonths = request.TermMonths,
        // ... other fields
    };
    
    await _repository.CreateAsync(application, cancellationToken);
    
    // ✅ PUBLISH AUDIT EVENT
    await _auditPublisher.PublishEventAsync(new LoanApplicationCreated
    {
        ApplicationId = application.Id,
        LoanNumber = application.LoanNumber,
        ClientId = application.ClientId,
        ProductCode = application.ProductCode,
        Amount = application.RequestedAmount,
        TermMonths = application.TermMonths,
        CreatedBy = _userContext.CurrentUserId,
        Timestamp = DateTime.UtcNow,
        CorrelationId = _correlationIdProvider.GetCorrelationId()
    }, cancellationToken);
    
    return MapToResponse(application);
}
```
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 998-1019]

**Approval Workers** (AC: 6):
- `ApprovalGrantedWorker` or similar worker publishes `LoanApprovalGranted` event after completing approval task
- `ApprovalRejectedWorker` publishes `LoanApprovalRejected` event after rejection
- Workers extract approval details from workflow variables and user context

**Agreement Worker** (AC: 7):
- Already implemented in Story 1.8
- `GenerateAgreementWorker` calls `AgreementGenerationService` which publishes `LoanAgreementGenerated` event
- No changes needed for this story

### RabbitMQ Configuration [Sources]

**Exchange and Queue Setup** (AC: 8):
```csharp
// Program.cs - MassTransit Configuration
builder.Services.AddMassTransit(x =>
{
    // Register consumers (if any for this service)
    x.AddConsumer<ClientKycRevokedConsumer>(); // From Story 1.6
    
    x.UsingRabbitMq((context, cfg) =>
    {
        cfg.Host(configuration["RabbitMQ:Host"], h =>
        {
            h.Username(configuration["RabbitMQ:Username"]);
            h.Password(configuration["RabbitMQ:Password"]);
        });
        
        // Configure publish topology for audit events
        cfg.Message<LoanApplicationCreated>(e => e.SetEntityName("intellifin.loan.events"));
        cfg.Message<LoanApplicationSubmitted>(e => e.SetEntityName("intellifin.loan.events"));
        cfg.Message<LoanCreditAssessmentCompleted>(e => e.SetEntityName("intellifin.loan.events"));
        cfg.Message<LoanApprovalGranted>(e => e.SetEntityName("intellifin.loan.events"));
        cfg.Message<LoanApprovalRejected>(e => e.SetEntityName("intellifin.loan.events"));
        cfg.Message<LoanAgreementGenerated>(e => e.SetEntityName("intellifin.loan.events"));
        cfg.Message<LoanDisbursed>(e => e.SetEntityName("intellifin.loan.events"));
        cfg.Message<LoanVersionCreated>(e => e.SetEntityName("intellifin.loan.events"));
        cfg.Message<LoanWorkflowStateChanged>(e => e.SetEntityName("intellifin.loan.events"));
        
        // Configure durable queues with dead-letter exchange
        cfg.Publish<LoanApplicationCreated>(p =>
        {
            p.Durable = true; // Survive broker restarts
        });
        
        // Dead-letter exchange configuration (at RabbitMQ level)
        // Queues in AdminService will have x-dead-letter-exchange set
        
        cfg.ConfigureEndpoints(context);
    });
});
```
[Source: brownfield-architecture.md#✅ Service Scaffolding and Infrastructure, lines 215-218; prd.md#Story 1.9, AC 8; prd.md#NFR4]

**Dead-Letter Exchange Strategy**:
- AdminService consumer queues configured with `x-dead-letter-exchange` argument
- Failed message delivery (after retries exhausted) routes to dead-letter queue
- Operations team monitors dead-letter queue for failed audit events
[Source: prd.md#Story 1.9, AC 8; prd.md#NFR4]

### ICorrelationIdProvider Implementation [Sources]

**Correlation ID Provider** (for distributed tracing):
```csharp
public interface ICorrelationIdProvider
{
    string GetCorrelationId();
    void SetCorrelationId(string correlationId);
}

public class CorrelationIdProvider : ICorrelationIdProvider
{
    private readonly IHttpContextAccessor _httpContextAccessor;
    private const string CorrelationIdHeaderName = "X-Correlation-Id";
    
    public string GetCorrelationId()
    {
        // Try to get from HTTP context first
        if (_httpContextAccessor.HttpContext != null)
        {
            if (_httpContextAccessor.HttpContext.Request.Headers.TryGetValue(
                CorrelationIdHeaderName, out var correlationId))
            {
                return correlationId.ToString();
            }
        }
        
        // Generate new if not present
        return Guid.NewGuid().ToString();
    }
    
    public void SetCorrelationId(string correlationId)
    {
        if (_httpContextAccessor.HttpContext != null)
        {
            _httpContextAccessor.HttpContext.Items["CorrelationId"] = correlationId;
        }
    }
}
```
[Source: brownfield-architecture.md#5. No Correlation ID Propagation, lines 1467-1473 - pattern for correlation ID management; prd.md#NFR5]

**Middleware for Correlation ID Propagation**:
```csharp
public class CorrelationIdMiddleware
{
    private readonly RequestDelegate _next;
    private const string CorrelationIdHeaderName = "X-Correlation-Id";
    
    public async Task InvokeAsync(HttpContext context, ICorrelationIdProvider correlationIdProvider)
    {
        // Extract or generate correlation ID
        var correlationId = context.Request.Headers[CorrelationIdHeaderName].FirstOrDefault()
            ?? Guid.NewGuid().ToString();
        
        // Store in provider
        correlationIdProvider.SetCorrelationId(correlationId);
        
        // Add to response headers
        context.Response.OnStarting(() =>
        {
            context.Response.Headers[CorrelationIdHeaderName] = correlationId;
            return Task.CompletedTask;
        });
        
        await _next(context);
    }
}
```

### File Locations [Sources]

- **New Service**: `apps/IntelliFin.LoanOriginationService/Services/AuditEventPublisher.cs` [NEW]
- **New Interface**: `apps/IntelliFin.LoanOriginationService/Services/IAuditEventPublisher.cs` [NEW]
- **New Provider**: `apps/IntelliFin.LoanOriginationService/Infrastructure/CorrelationIdProvider.cs` [NEW]
- **New Interface**: `apps/IntelliFin.LoanOriginationService/Infrastructure/ICorrelationIdProvider.cs` [NEW]
- **New Middleware**: `apps/IntelliFin.LoanOriginationService/Middleware/CorrelationIdMiddleware.cs` [NEW]
- **New Interface**: `apps/IntelliFin.LoanOriginationService/Events/ICorrelatedEvent.cs` [NEW]
- **New Event Records**: `apps/IntelliFin.LoanOriginationService/Events/` folder [NEW]
  - `LoanApplicationCreated.cs`
  - `LoanApplicationSubmitted.cs`
  - `LoanCreditAssessmentCompleted.cs`
  - `LoanApprovalGranted.cs`
  - `LoanApprovalRejected.cs`
  - `LoanAgreementGenerated.cs` [ALREADY EXISTS from Story 1.8]
  - `LoanDisbursed.cs`
  - `LoanVersionCreated.cs`
  - `LoanWorkflowStateChanged.cs`
- **Modify Service**: `apps/IntelliFin.LoanOriginationService/Services/LoanApplicationService.cs` [MODIFY - add event publishing]
- **Modify Service**: `apps/IntelliFin.LoanOriginationService/Services/LoanVersioningService.cs` [MODIFY - add event publishing for version creation]
- **Modify Configuration**: `apps/IntelliFin.LoanOriginationService/Program.cs` [MODIFY - register services, configure MassTransit topology]
[Source: brownfield-architecture.md#❌ 6. Comprehensive Audit Events, lines 1023-1027; brownfield-architecture.md#4.3 Code Organization]

### Technology Stack [Sources]

**MassTransit with RabbitMQ**: Already configured [Source: brownfield-architecture.md#✅ Service Scaffolding and Infrastructure, lines 215-218]
- Version: MassTransit 8.0+ with RabbitMQ transport
- Exchange: `intellifin.loan.events` (fanout or topic exchange)
- Durable queues: Messages persisted to disk
- Dead-letter exchange: Failed messages routed for manual intervention

**Correlation ID Management**: Custom implementation
- `ICorrelationIdProvider` for generating and retrieving correlation IDs
- `CorrelationIdMiddleware` for HTTP request/response propagation
- Correlation IDs passed in message headers and event properties

**Structured Logging**: Serilog with correlation IDs [Source: brownfield-architecture.md#4.3 Coding Standards]
- All event publications logged with correlation IDs
- Correlation IDs included in all structured log entries

### Coding Standards [Sources]

- **Async/await**: All event publishing async with CancellationToken propagation [Source: brownfield-architecture.md#4.3 Coding Standards]
- **Fire-and-forget**: Event publishing should not block business operations [Source: prd.md#NFR4]
- **Structured logging**: Log all event publications with correlation IDs, event types, timestamps [Source: brownfield-architecture.md#4.3 Coding Standards]
- **Error handling**: Event publishing failures should be logged but not throw exceptions (fire-and-forget pattern)
- **Correlation IDs**: Must be propagated across all service calls and event publications [Source: prd.md#NFR5]
- **XML comments**: Required for all public interfaces and event records [Source: brownfield-architecture.md#4.3 Documentation Standards]

### Testing Requirements [Sources]

**Unit Tests (xUnit)**
- Test `AuditEventPublisher.PublishEventAsync` calls `IPublishEndpoint.Publish` [Source: prd.md#Story 1.9, AC 1, 2]
- Test correlation ID injection when not provided in event
- Test correlation ID propagation from `ICorrelationIdProvider`
- Test event publishing does not throw exceptions (fire-and-forget)
- Test `CorrelationIdProvider.GetCorrelationId` retrieves from HTTP context
- Test `CorrelationIdProvider.GetCorrelationId` generates new GUID when not in HTTP context
- Mock `IPublishEndpoint`, `ICorrelationIdProvider`, `IHttpContextAccessor`

**Integration Tests with RabbitMQ (AC: 9)**
- Set up TestContainers for RabbitMQ [Source: prd.md#Story 1.9, AC 9]
- Test publish `LoanApplicationCreated` event → verify message in RabbitMQ queue [Source: prd.md#Story 1.9, IV1]
- Test all 9 event types → verify each appears in correct exchange
- Test event payload serialization/deserialization
- Test correlation ID present in message headers
- Test dead-letter exchange routing: simulate consumer failure (reject message without requeue) → verify message routes to DLX [Source: prd.md#Story 1.9, IV3, AC 8]
- Test framework: xUnit with TestContainers for RabbitMQ

**End-to-End Event Sequence Test (IV2)**
- Create loan via API → verify `LoanApplicationCreated` event
- Submit loan → verify `LoanApplicationSubmitted` event
- Complete credit assessment → verify `LoanCreditAssessmentCompleted` event
- Approve loan → verify `LoanApprovalGranted` event
- Generate agreement (automatic) → verify `LoanAgreementGenerated` event (already tested in Story 1.8)
- Verify all events have same correlation ID (tracing through workflow) [Source: prd.md#Story 1.9, IV2]
- Verify events published in correct chronological order

### Performance Constraints [Sources]

- Event publishing must not block API response (fire-and-forget) [Source: prd.md#NFR4]
- Event publishing latency <10ms at p95 (MassTransit internal buffering)
- RabbitMQ exchange must handle 1000+ messages/second without performance degradation
- Dead-letter queue processing by operations team within 1 hour of failure
- Correlation IDs must be propagated with <1ms overhead [Source: prd.md#NFR5]

### Dependencies
- **Story 1.8**: Agreement generation publishes `LoanAgreementGenerated` event [Source: prd.md#Story 1.9 Dependencies]
- **All Previous Stories**: All services that modify loan state need event publishing
- **AdminService**: Must be operational to consume audit events from RabbitMQ

## Tasks / Subtasks

- [ ] Create ICorrelatedEvent interface
  - [ ] Define `ICorrelatedEvent` interface with `CorrelationId` property
  - [ ] Add XML documentation comments

- [ ] Create event record models (AC: 3)
  - [ ] Create `Events/LoanApplicationCreated.cs` implementing `ICorrelatedEvent` [Source: prd.md#Story 1.9, AC 3]
  - [ ] Create `Events/LoanApplicationSubmitted.cs` implementing `ICorrelatedEvent`
  - [ ] Create `Events/LoanCreditAssessmentCompleted.cs` implementing `ICorrelatedEvent`
  - [ ] Create `Events/LoanApprovalGranted.cs` implementing `ICorrelatedEvent`
  - [ ] Create `Events/LoanApprovalRejected.cs` implementing `ICorrelatedEvent`
  - [ ] Verify `Events/LoanAgreementGenerated.cs` exists from Story 1.8 (no changes needed)
  - [ ] Create `Events/LoanDisbursed.cs` implementing `ICorrelatedEvent`
  - [ ] Create `Events/LoanVersionCreated.cs` implementing `ICorrelatedEvent`
  - [ ] Create `Events/LoanWorkflowStateChanged.cs` implementing `ICorrelatedEvent`
  - [ ] Add XML documentation comments for all event records

- [ ] Create ICorrelationIdProvider interface and implementation (AC: 4)
  - [ ] Define `ICorrelationIdProvider` interface with `GetCorrelationId()` and `SetCorrelationId(string)` methods
  - [ ] Implement `CorrelationIdProvider` class
  - [ ] Inject `IHttpContextAccessor` dependency
  - [ ] Implement `GetCorrelationId()`: extract from HTTP headers or generate new GUID [Source: prd.md#Story 1.9, AC 4; prd.md#NFR5]
  - [ ] Implement `SetCorrelationId()`: store in HTTP context items
  - [ ] Add XML documentation comments

- [ ] Create CorrelationIdMiddleware
  - [ ] Implement middleware to extract/generate correlation ID from HTTP headers
  - [ ] Set correlation ID in `ICorrelationIdProvider`
  - [ ] Add correlation ID to response headers
  - [ ] Add structured logging for correlation ID extraction/generation

- [ ] Create IAuditEventPublisher interface (AC: 1)
  - [ ] Define `Task PublishEventAsync<T>(T auditEvent, CancellationToken cancellationToken)` signature
  - [ ] Define `Task PublishEventsAsync<T>(IEnumerable<T> auditEvents, CancellationToken cancellationToken)` signature (batch publishing)
  - [ ] Add XML documentation comments

- [ ] Implement AuditEventPublisher service (AC: 1, 2, 4)
  - [ ] Create `Services/AuditEventPublisher.cs` implementing `IAuditEventPublisher`
  - [ ] Inject `IPublishEndpoint`, `ICorrelationIdProvider`, `ILogger<AuditEventPublisher>` dependencies
  - [ ] Implement `PublishEventAsync<T>` method
  - [ ] Get correlation ID from provider [Source: prd.md#Story 1.9, AC 4]
  - [ ] Inject correlation ID into event if not present (check `ICorrelatedEvent`)
  - [ ] Publish to RabbitMQ using `IPublishEndpoint.Publish` [Source: prd.md#Story 1.9, AC 2]
  - [ ] Set message headers: CorrelationId, PublishedAt, ServiceName
  - [ ] Add structured logging: event type, correlation ID [Source: prd.md#NFR5]
  - [ ] Implement `PublishEventsAsync` for batch publishing (calls `PublishEventAsync` for each)
  - [ ] Ensure fire-and-forget: do not throw exceptions on publish failure (log error instead)

- [ ] Register services in Program.cs
  - [ ] Add `builder.Services.AddScoped<IAuditEventPublisher, AuditEventPublisher>();`
  - [ ] Add `builder.Services.AddSingleton<ICorrelationIdProvider, CorrelationIdProvider>();`
  - [ ] Ensure `IHttpContextAccessor` registered: `builder.Services.AddHttpContextAccessor();`
  - [ ] Register `CorrelationIdMiddleware`: `app.UseMiddleware<CorrelationIdMiddleware>();` (early in pipeline)

- [ ] Configure MassTransit publish topology (AC: 2, 8)
  - [ ] Update MassTransit configuration in Program.cs
  - [ ] Configure all event messages to use `intellifin.loan.events` exchange [Source: prd.md#Story 1.9, AC 2]
  - [ ] Set messages as durable (survive broker restarts) [Source: prd.md#Story 1.9, AC 8]
  - [ ] Document dead-letter exchange configuration (handled by AdminService consumer queues)
  - [ ] Verify MassTransit configuration includes `ConfigureEndpoints(context)`

- [ ] Modify LoanApplicationService to publish events (AC: 5)
  - [ ] Inject `IAuditEventPublisher` dependency into `LoanApplicationService`
  - [ ] In `CreateApplicationAsync`: Publish `LoanApplicationCreated` event after creating loan [Source: prd.md#Story 1.9, AC 5]
  - [ ] In `SubmitApplicationAsync` (if exists): Publish `LoanApplicationSubmitted` event
  - [ ] In `ApproveApplicationAsync`: Publish `LoanApprovalGranted` event after approval
  - [ ] In `RejectApplicationAsync`: Publish `LoanApprovalRejected` event after rejection
  - [ ] Ensure event publishing does not throw exceptions (fire-and-forget)
  - [ ] Add structured logging for all event publications

- [ ] Modify LoanVersioningService to publish events
  - [ ] Inject `IAuditEventPublisher` dependency
  - [ ] In `CreateNewVersionAsync`: Publish `LoanVersionCreated` event after version created
  - [ ] Include version details: PreviousVersion, NewVersion, ModificationReason, ChangedFields

- [ ] Create approval workers for event publishing (AC: 6)
  - [ ] Create `Workers/ApprovalGrantedWorker.cs` (or modify existing approval worker)
  - [ ] After approval task completion, publish `LoanApprovalGranted` event [Source: prd.md#Story 1.9, AC 6]
  - [ ] Extract approval details from workflow variables (approvedBy, approverRole, approvalLevel, isDualControl)
  - [ ] Create `Workers/ApprovalRejectedWorker.cs` (or modify existing rejection worker)
  - [ ] After rejection task completion, publish `LoanApprovalRejected` event
  - [ ] Extract rejection details from workflow variables (rejectedBy, rejectionReason, riskGrade)

- [ ] Verify AgreementGenerationService event publishing (AC: 7)
  - [ ] Review Story 1.8 implementation: `LoanAgreementGenerated` event already published [Source: prd.md#Story 1.9, AC 7]
  - [ ] No changes needed for this story (event publishing already implemented)

- [ ] Write unit tests for AuditEventPublisher
  - [ ] Test `PublishEventAsync` calls `IPublishEndpoint.Publish` with correct event [Source: prd.md#Story 1.9, AC 1, 2]
  - [ ] Test correlation ID injected when not provided in event [Source: prd.md#Story 1.9, AC 4]
  - [ ] Test correlation ID retrieved from `ICorrelationIdProvider`
  - [ ] Test message headers set correctly (CorrelationId, PublishedAt, ServiceName)
  - [ ] Test `PublishEventsAsync` calls `PublishEventAsync` for each event
  - [ ] Test fire-and-forget: no exceptions thrown on publish failure
  - [ ] Mock `IPublishEndpoint`, `ICorrelationIdProvider`

- [ ] Write unit tests for CorrelationIdProvider
  - [ ] Test `GetCorrelationId` retrieves from HTTP headers when present
  - [ ] Test `GetCorrelationId` generates new GUID when not in HTTP context
  - [ ] Test `GetCorrelationId` generates new GUID when header not present
  - [ ] Test `SetCorrelationId` stores in HTTP context items
  - [ ] Mock `IHttpContextAccessor`

- [ ] Write unit tests for CorrelationIdMiddleware
  - [ ] Test middleware extracts correlation ID from request header
  - [ ] Test middleware generates new correlation ID when header not present
  - [ ] Test middleware sets correlation ID in `ICorrelationIdProvider`
  - [ ] Test middleware adds correlation ID to response headers

- [ ] Write integration tests with RabbitMQ (AC: 9)
  - [ ] Set up TestContainers for RabbitMQ [Source: prd.md#Story 1.9, AC 9]
  - [ ] Test publish `LoanApplicationCreated` event → verify message in RabbitMQ exchange [Source: prd.md#Story 1.9, IV1]
  - [ ] Test all 9 event types → verify each appears in `intellifin.loan.events` exchange
  - [ ] Test event payload serialization: verify JSON structure correct
  - [ ] Test correlation ID present in message headers and event payload
  - [ ] Test message durability: verify messages persisted (survive broker restart)
  - [ ] Test framework: xUnit with TestContainers for RabbitMQ

- [ ] Write integration test for dead-letter exchange (IV3)
  - [ ] Set up RabbitMQ with dead-letter exchange and queue
  - [ ] Publish audit event
  - [ ] Simulate AdminService consumer failure: reject message without requeue [Source: prd.md#Story 1.9, IV3]
  - [ ] Verify message routes to dead-letter queue (at-least-once delivery) [Source: prd.md#Story 1.9, AC 8]
  - [ ] Verify message retries exhausted before DLX routing

- [ ] Integration verification: Single event publishing (IV1)
  - [ ] Create loan via API with correlation ID in request header
  - [ ] Verify `LoanApplicationCreated` event published to RabbitMQ [Source: prd.md#Story 1.9, IV1]
  - [ ] Verify event payload contains correct loan data (applicationId, loanNumber, clientId, productCode, amount, termMonths)
  - [ ] Verify correlation ID matches request header
  - [ ] Verify event timestamp is recent (<1 second old)

- [ ] Integration verification: End-to-end event sequence (IV2)
  - [ ] Start with single correlation ID for entire workflow
  - [ ] Create loan → verify `LoanApplicationCreated` event
  - [ ] Submit loan → verify `LoanApplicationSubmitted` event (if implemented)
  - [ ] Complete credit assessment (manual or automatic) → verify `LoanCreditAssessmentCompleted` event
  - [ ] Approve loan → verify `LoanApprovalGranted` event
  - [ ] Workflow triggers agreement generation → verify `LoanAgreementGenerated` event
  - [ ] Verify all 4-5 events published in sequence [Source: prd.md#Story 1.9, IV2]
  - [ ] Verify all events have same correlation ID (distributed tracing)
  - [ ] Verify events ordered chronologically by timestamp

- [ ] Integration verification: Dead-letter queue routing (IV3)
  - [ ] Publish audit event to RabbitMQ
  - [ ] Configure test consumer to always reject messages (simulate AdminService failure)
  - [ ] After retry exhaustion, verify message routes to dead-letter queue [Source: prd.md#Story 1.9, IV3]
  - [ ] Verify original message payload preserved in DLX
  - [ ] Verify message headers include failure reason

- [ ] Performance verification
  - [ ] Verify event publishing does not block API response (fire-and-forget) [Source: prd.md#NFR4]
  - [ ] Verify event publishing latency <10ms at p95
  - [ ] Verify correlation ID propagation overhead <1ms [Source: prd.md#NFR5]
  - [ ] Load test: 100 concurrent loan creations → verify all events published without loss

- [ ] Documentation
  - [ ] Add README section: "Audit Event Publishing" with event catalog and schemas
  - [ ] Document RabbitMQ exchange topology: `intellifin.loan.events` with durable queues
  - [ ] Document dead-letter exchange strategy for failed deliveries
  - [ ] Document correlation ID propagation: HTTP headers, event properties, message headers
  - [ ] Document event consumption by AdminService (high-level overview)
  - [ ] Add sequence diagram: Loan lifecycle with all published events

## Change Log

| Date       | Version | Description                      | Author |
|------------|---------|----------------------------------|--------|
| 2025-10-17 | 0.1     | Initial draft created            | SM     |

## Dev Agent Record

*(This section will be populated by the development agent during implementation)*

### Agent Model Used

*(To be filled by dev agent)*

### Debug Log References

*(To be filled by dev agent)*

### Completion Notes

*(To be filled by dev agent)*

### File List

*(To be filled by dev agent)*

## QA Results

*(To be filled by QA agent)*
