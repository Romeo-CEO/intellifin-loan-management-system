# Story 1.7: Dual Control Validation Service and Workflow Enforcement

Status: Draft

## Story

**As a** compliance officer,  
**I want** the system to prevent loan approvers from approving their own loan applications,  
**so that** we maintain segregation of duties and meet Bank of Zambia regulatory requirements.

## Acceptance Criteria

1. `DualControlValidator` service implemented with `ValidateApprovalAsync(applicationId, approverUserId)` method
2. Validator checks: approver != creator, approver != assessor; throws `DualControlViolationException` if match
3. Validator publishes `LoanApprovalAttempted` audit event with IP address, timestamp, outcome (success/blocked)
4. BPMN approval tasks updated with assignee exclusion: `candidateGroups="credit-analysts" excludeUsers="#{createdBy}"`
5. `LoanApplicationService.ApproveApplicationAsync` calls DualControlValidator before processing approval (API-level defense in depth)
6. API returns 403 Forbidden with error code `DUAL_CONTROL_VIOLATION` if validation fails
7. Unit tests verify all violation scenarios (self-approval, approver-as-assessor, approver-as-creator)
8. Integration test simulates same user attempting approval via API and via Camunda Tasklist - both blocked

## Integration Verification

- **IV1**: Different user approves loan created by another user → succeeds as normal (no breaking change to valid approvals)
- **IV2**: Loan creator attempts to approve their own loan via API → blocked with clear error message and error code `DUAL_CONTROL_VIOLATION`
- **IV3**: Credit assessor assigned approval task in Camunda Tasklist → task does not appear in their queue (filtered by `excludeUsers` expression)
- **IV4**: Loan officer with dual roles (creator + approver group membership) → cannot approve own loans (dual control enforced)

## Dev Notes

### Previous Story Insights
- Story 1.2 implemented loan number generation and versioning
- Story 1.3 integrated Vault for product configurations
- Story 1.4 implemented `IClientManagementClient` for KYC verification
- Story 1.5 designed and deployed Camunda BPMN workflow with approval routing gateway
- Story 1.6 implemented `KycVerificationWorker` and event-driven KYC revocation handling
- Existing `LoanApplicationService` has approval methods that need dual control validation injection [Source: brownfield-architecture.md#Current State Analysis]

### Current State Problem [Sources]

**Missing Dual Control Enforcement** - No validation to prevent self-approval
- Architecture document specifies dual control at two layers: Camunda workflow + API-level [Source: brownfield-architecture.md#Security and Compliance Considerations, lines 1479-1483]
- Current implementation has no segregation of duties enforcement [Source: prd.md#1.2 What is MISSING, line 45]
- Approval methods in `LoanApplicationService` do not check creator/assessor identity [Source: brownfield-architecture.md#❌ Workflow Integration - no dual control checks]

**Regulatory Requirement**: Bank of Zambia requires segregation of duties and dual control for loan approvals [Source: prd.md#1.4 Background Context, line 75; loan-approval-workflow.md#Internal Control Compliance, lines 334-336]

**Approval Authority Matrix Requirements**: [Source: loan-approval-workflow.md#2.2 Approval Authority Matrix]
- **Rule Set 1**: Amount ≤50K AND Grade A/B → Single Credit Analyst approval
- **Rule Set 2**: Amount >50K AND ≤250K OR Grade C → Single Head of Credit approval  
- **Rule Set 3**: Amount >250K OR Grade D/F → Dual Control (Head of Credit + CEO)

**Dual Control Principle**: Approver cannot be the same person who created or assessed the loan [Source: loan-approval-workflow.md#Workflow Design Principles, lines 27-31]

### DualControlValidator Implementation [Sources]

**Validator Service Pattern**:
```csharp
public class DualControlValidator : IDualControlValidator
{
    private readonly LmsDbContext _dbContext;
    private readonly IPublishEndpoint _publishEndpoint;
    private readonly IHttpContextAccessor _httpContextAccessor;
    private readonly ILogger<DualControlValidator> _logger;
    
    public async Task ValidateApprovalAsync(
        Guid applicationId, 
        string approverUserId,
        CancellationToken cancellationToken)
    {
        _logger.LogInformation(
            "Validating dual control for loan {ApplicationId}, Approver: {ApproverUserId}",
            applicationId, approverUserId);
        
        // Fetch loan application with creator and assessor info
        var application = await _dbContext.LoanApplications
            .Include(la => la.CreditAssessment)
            .FirstOrDefaultAsync(la => la.Id == applicationId, cancellationToken);
        
        if (application == null)
        {
            throw new NotFoundException($"Loan application {applicationId} not found");
        }
        
        // Extract IP address for audit trail
        var ipAddress = _httpContextAccessor.HttpContext?.Connection.RemoteIpAddress?.ToString() 
            ?? "Unknown";
        
        // Check 1: Approver != Creator
        if (application.CreatedBy == approverUserId)
        {
            _logger.LogWarning(
                "Dual control violation: Approver {ApproverUserId} is the creator of loan {LoanNumber}",
                approverUserId, application.LoanNumber);
            
            // Publish audit event for violation attempt
            await PublishApprovalAttemptEventAsync(
                application, approverUserId, ipAddress, "BLOCKED_SELF_APPROVAL", cancellationToken);
            
            throw new DualControlViolationException(
                applicationId, 
                approverUserId, 
                "Approver cannot approve their own loan application");
        }
        
        // Check 2: Approver != Assessor (if credit assessment exists)
        if (application.CreditAssessment != null 
            && application.CreditAssessment.AssessedBy == approverUserId)
        {
            _logger.LogWarning(
                "Dual control violation: Approver {ApproverUserId} is the assessor of loan {LoanNumber}",
                approverUserId, application.LoanNumber);
            
            // Publish audit event for violation attempt
            await PublishApprovalAttemptEventAsync(
                application, approverUserId, ipAddress, "BLOCKED_APPROVER_AS_ASSESSOR", cancellationToken);
            
            throw new DualControlViolationException(
                applicationId, 
                approverUserId, 
                "Approver cannot approve loans they assessed");
        }
        
        // Dual control validation passed
        _logger.LogInformation(
            "Dual control validation passed for loan {LoanNumber}, Approver: {ApproverUserId}",
            application.LoanNumber, approverUserId);
        
        // Publish audit event for successful validation
        await PublishApprovalAttemptEventAsync(
            application, approverUserId, ipAddress, "VALIDATION_PASSED", cancellationToken);
    }
    
    private async Task PublishApprovalAttemptEventAsync(
        LoanApplication application,
        string approverUserId,
        string ipAddress,
        string outcome,
        CancellationToken cancellationToken)
    {
        await _publishEndpoint.Publish(new LoanApprovalAttempted
        {
            LoanApplicationId = application.Id,
            LoanNumber = application.LoanNumber,
            ApproverUserId = approverUserId,
            CreatedByUserId = application.CreatedBy,
            AssessedByUserId = application.CreditAssessment?.AssessedBy,
            IpAddress = ipAddress,
            Outcome = outcome,
            AttemptedAt = DateTime.UtcNow,
            CorrelationId = Guid.NewGuid()
        }, cancellationToken);
    }
}
```
[Source: brownfield-architecture.md#1. Dual Control Enforcement, lines 1479-1483 - pattern adapted with audit event publishing; prd.md#Story 1.7, AC 1, 2, 3]

### BPMN Task Assignment with Exclusion [Sources]

**Approval Task Configuration in BPMN**:
```xml
<bpmn:userTask id="CreditAnalystApproval" name="Credit Analyst Approval">
  <bpmn:extensionElements>
    <zeebe:assignmentDefinition 
      candidateGroups="credit-analysts" 
      excludeUsers="#{createdBy},#{assessedBy}" />
    <zeebe:taskHeaders>
      <zeebe:header key="taskType" value="approval" />
      <zeebe:header key="requiredAuthority" value="credit-analyst" />
    </zeebe:taskHeaders>
  </bpmn:extensionElements>
</bpmn:userTask>

<bpmn:userTask id="HeadOfCreditApproval" name="Head of Credit Approval">
  <bpmn:extensionElements>
    <zeebe:assignmentDefinition 
      candidateGroups="head-of-credit" 
      excludeUsers="#{createdBy},#{assessedBy}" />
  </bpmn:extensionElements>
</bpmn:userTask>

<bpmn:userTask id="CEOApproval" name="CEO Final Approval">
  <bpmn:extensionElements>
    <zeebe:assignmentDefinition 
      candidateGroups="ceo" 
      excludeUsers="#{createdBy},#{assessedBy},#{firstApproverId}" />
  </bpmn:extensionElements>
</bpmn:userTask>
```
[Source: prd.md#Story 1.7, AC 4; loan-approval-workflow.md#2.2 Approval Authority Matrix - exclusion pattern for dual control scenarios]

**BPMN Variables for Exclusion**:
- `createdBy`: User ID who created the loan application
- `assessedBy`: User ID who performed credit assessment
- `firstApproverId`: User ID who performed first approval (for dual control scenarios)

These variables must be set when starting the workflow or completing tasks [Source: prd.md#Story 1.5, AC 6]

### Domain Exceptions [Sources]

**DualControlViolationException** - Thrown when approver violates segregation of duties
```csharp
public class DualControlViolationException : Exception
{
    public Guid ApplicationId { get; }
    public string ApproverUserId { get; }
    public string ViolationType { get; }
    
    public DualControlViolationException(
        Guid applicationId, 
        string approverUserId, 
        string message) 
        : base(message)
    {
        ApplicationId = applicationId;
        ApproverUserId = approverUserId;
        ViolationType = DetermineViolationType(message);
    }
    
    private string DetermineViolationType(string message)
    {
        if (message.Contains("own loan")) return "SELF_APPROVAL";
        if (message.Contains("assessed")) return "APPROVER_AS_ASSESSOR";
        return "UNKNOWN_VIOLATION";
    }
}
```
[Source: prd.md#Story 1.7, AC 2; brownfield-architecture.md#4.3 Exception handling - domain exceptions for business rule violations]

### API Error Response Mapping [Sources]

**Controller Exception Handling** - Map dual control violations to HTTP responses:
```csharp
[HttpPost("{id}/approve")]
public async Task<IActionResult> ApproveApplication(
    Guid id,
    [FromBody] ApproveApplicationRequest request,
    CancellationToken cancellationToken)
{
    try
    {
        // Get current user ID from authentication context
        var approverUserId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        
        if (string.IsNullOrEmpty(approverUserId))
        {
            return Unauthorized("User identity not found");
        }
        
        var result = await _loanApplicationService
            .ApproveApplicationAsync(id, approverUserId, request, cancellationToken);
        
        return Ok(result);
    }
    catch (DualControlViolationException ex)
    {
        return StatusCode(403, new 
        {
            ErrorCode = "DUAL_CONTROL_VIOLATION",
            Message = ex.Message,
            ApplicationId = ex.ApplicationId,
            ApproverUserId = ex.ApproverUserId,
            ViolationType = ex.ViolationType,
            ActionRequired = "A different user must approve this loan application to maintain segregation of duties"
        });
    }
    catch (NotFoundException ex)
    {
        return NotFound(new { ErrorCode = "NOT_FOUND", Message = ex.Message });
    }
}
```
[Source: prd.md#Story 1.7, AC 6]

### Integration Points [Sources]

**LoanApplicationService.ApproveApplicationAsync Modification**:
1. Inject `IDualControlValidator` dependency
2. **Before** processing approval, call `await _dualControlValidator.ValidateApprovalAsync(applicationId, approverUserId, cancellationToken)` [Source: prd.md#Story 1.7, AC 5]
3. If validation throws exception, propagate to controller for error response
4. If validation passes, proceed with existing approval logic
5. Maintain existing method signature for backward compatibility [Source: prd.md#CR1]

**Workflow Integration**:
- Zeebe job workers for approval tasks must set workflow variables after approval [Source: Story 1.5 BPMN implementation]
- Example: After Head of Credit approval, set `firstApproverId` variable for CEO exclusion
- Camunda Tasklist automatically filters tasks using `excludeUsers` expression [Source: prd.md#Story 1.7, AC 4]

### Event Schema [Sources]

**LoanApprovalAttempted Event** (published to AdminService):
```csharp
public class LoanApprovalAttempted
{
    public Guid LoanApplicationId { get; set; }
    public string LoanNumber { get; set; }
    public string ApproverUserId { get; set; }
    public string CreatedByUserId { get; set; }
    public string? AssessedByUserId { get; set; }
    public string IpAddress { get; set; }
    public string Outcome { get; set; } // "VALIDATION_PASSED", "BLOCKED_SELF_APPROVAL", "BLOCKED_APPROVER_AS_ASSESSOR"
    public DateTime AttemptedAt { get; set; }
    public Guid CorrelationId { get; set; }
}
```
[Source: prd.md#Story 1.7, AC 3; prd.md#FR9 - audit events for all state changes]

### Database Schema Requirements [Sources]

**Existing Columns Used**:
- `LoanApplications.CreatedBy` (user ID who created the loan) - Already exists
- `CreditAssessments.AssessedBy` (user ID who performed assessment) - Already exists

**No Schema Changes Required** - Leveraging existing audit columns [Source: brownfield-architecture.md#LoanApplication Model, lines 230-243]

### File Locations [Sources]

- **New Service**: `apps/IntelliFin.LoanOriginationService/Services/DualControlValidator.cs` [NEW]
- **New Interface**: `apps/IntelliFin.LoanOriginationService/Services/IDualControlValidator.cs` [NEW]
- **New Exception**: `apps/IntelliFin.LoanOriginationService/Exceptions/DualControlViolationException.cs` [NEW]
- **New Event Model**: `apps/IntelliFin.LoanOriginationService/Events/LoanApprovalAttempted.cs` [NEW]
- **Modify Service**: `apps/IntelliFin.LoanOriginationService/Services/LoanApplicationService.cs` [MODIFY]
- **Modify Controller**: `apps/IntelliFin.LoanOriginationService/Controllers/LoanApplicationController.cs` [MODIFY]
- **Modify BPMN**: `apps/IntelliFin.LoanOriginationService/Workflows/loan-origination-process.bpmn` [MODIFY]
[Source: brownfield-architecture.md#4.3 Code Organization and Standards, prd.md#4.3]

### Technology Stack [Sources]

**Validation Service**: Standard .NET dependency injection pattern
- Inject `IDualControlValidator` into `LoanApplicationService`
- Register as scoped service: `services.AddScoped<IDualControlValidator, DualControlValidator>()`
[Source: prd.md#4.2 Technical Constraints]

**BPMN Exclusion**: Zeebe BPMN expressions
- `excludeUsers` attribute in `zeebe:assignmentDefinition` element
- Supports comma-separated list and expression language `#{variableName}`
[Source: Camunda 8 documentation - user task assignment]

**Audit Events**: MassTransit with RabbitMQ (already configured)
- Publish `LoanApprovalAttempted` events to `intellifin.loan.events` exchange
- Durable queues with at-least-once delivery guarantee
[Source: brownfield-architecture.md#✅ Service Scaffolding and Infrastructure, lines 215-218; prd.md#NFR4]

**HTTP Context**: ASP.NET Core `IHttpContextAccessor`
- Extract IP address for audit trail: `_httpContextAccessor.HttpContext?.Connection.RemoteIpAddress`
- Extract user ID from claims: `User.FindFirst(ClaimTypes.NameIdentifier)?.Value`
[Source: .NET Core best practices for audit logging]

### Coding Standards [Sources]

- **Async/await**: All I/O operations async with CancellationToken propagation [Source: brownfield-architecture.md#4.3 Coding Standards]
- **Structured logging**: Use Serilog with correlation IDs for validation attempts, violations, and successes [Source: brownfield-architecture.md#4.3 Coding Standards]
- **Exception handling**: Domain exception (`DualControlViolationException`) for business rule violations [Source: brownfield-architecture.md#4.3 Coding Standards]
- **Audit trail**: Publish `LoanApprovalAttempted` event for ALL approval attempts (success and blocked) [Source: prd.md#NFR5]
- **XML comments**: Required for all public interfaces and service classes [Source: brownfield-architecture.md#4.3 Documentation Standards]

### Testing Requirements [Sources]

**Unit Tests (xUnit)**
- Test validator blocks self-approval (approver == creator) [Source: prd.md#Story 1.7, AC 7]
- Test validator blocks approver-as-assessor (approver == assessor) [Source: prd.md#Story 1.7, AC 7]
- Test validator allows valid approval (approver != creator AND approver != assessor) [Source: prd.md#Story 1.7, IV1]
- Test validator publishes `LoanApprovalAttempted` event for all scenarios [Source: prd.md#Story 1.7, AC 3]
- Test `DualControlViolationException` contains correct violation type
- Mock `LmsDbContext`, `IPublishEndpoint`, `IHttpContextAccessor` for unit tests

**Integration Tests**
- Test API endpoint blocks self-approval with 403 Forbidden and error code `DUAL_CONTROL_VIOLATION` [Source: prd.md#Story 1.7, AC 6, IV2]
- Test API endpoint allows valid approval with 200 OK [Source: prd.md#Story 1.7, IV1]
- Test Camunda Tasklist filters tasks using `excludeUsers` expression [Source: prd.md#Story 1.7, AC 8, IV3]
- Test dual control scenario: Head of Credit approval → CEO approval (CEO != Head of Credit) [Source: loan-approval-workflow.md#Rule Set 3]
- Test audit events published to RabbitMQ for approval attempts
- Test framework: xUnit with TestContainers for SQL Server and RabbitMQ [Source: prd.md#4.2 Testing Integration Strategy]

**BPMN Validation**
- Use Camunda Modeler to validate BPMN with `excludeUsers` expressions
- Test workflow execution with Camunda Zeebe Process Test library [Source: prd.md#4.2 Testing Integration Strategy]

### Performance Constraints [Sources]

- Validation query must complete within 100ms (simple indexed query on CreatedBy, AssessedBy) [Source: prd.md#NFR1]
- Overall approval API response time must remain <500ms at p95 [Source: prd.md#NFR1]
- Audit event publishing must not block approval response (fire-and-forget) [Source: prd.md#NFR4]
- Correlation IDs must be propagated for distributed tracing [Source: prd.md#NFR5]

### User Experience Requirements [Sources]

**Error Messages** - Must be clear and actionable:
- "You cannot approve this loan application because you created it. Another user must approve to maintain segregation of duties."
- "You cannot approve this loan application because you performed the credit assessment. Another user must approve to maintain segregation of duties."
[Source: prd.md#Story 1.7, AC 6]

**Camunda Tasklist Filtering**: 
- Tasks automatically filtered from user's queue if excluded
- No manual "I cannot approve this" action required
- User never sees tasks they're excluded from [Source: prd.md#Story 1.7, IV3]

### Dependencies
- **Story 1.5**: Camunda BPMN workflow with approval tasks must be deployed [Source: prd.md#Story 1.7 Dependencies]
- **Story 1.6**: Workflow orchestration operational for task assignment and routing [Source: prd.md#Story 1.7 Dependencies]

## Tasks / Subtasks

- [ ] Create domain exception (AC: 2)
  - [ ] Create `Exceptions/DualControlViolationException.cs` with ApplicationId, ApproverUserId, ViolationType properties
  - [ ] Implement `DetermineViolationType` helper method to classify violation
  - [ ] Override Message property with user-friendly error messages
  - [ ] Add XML documentation comments

- [ ] Create event model (AC: 3)
  - [ ] Create `Events/LoanApprovalAttempted.cs` with properties: LoanApplicationId, LoanNumber, ApproverUserId, CreatedByUserId, AssessedByUserId, IpAddress, Outcome, AttemptedAt, CorrelationId
  - [ ] Add XML documentation comments for all event properties

- [ ] Create IDualControlValidator interface (AC: 1)
  - [ ] Define `Task ValidateApprovalAsync(Guid applicationId, string approverUserId, CancellationToken cancellationToken)` signature
  - [ ] Add XML documentation comments explaining dual control validation rules

- [ ] Implement DualControlValidator service (AC: 1, 2, 3)
  - [ ] Create `Services/DualControlValidator.cs` implementing `IDualControlValidator`
  - [ ] Inject `LmsDbContext`, `IPublishEndpoint`, `IHttpContextAccessor`, `ILogger<DualControlValidator>` dependencies
  - [ ] Implement `ValidateApprovalAsync` method
  - [ ] Query loan application with creator and assessor info (include CreditAssessment) [Source: prd.md#Story 1.7, AC 2]
  - [ ] Check 1: Validate approver != creator → throw `DualControlViolationException` if match [Source: prd.md#Story 1.7, AC 2]
  - [ ] Check 2: Validate approver != assessor → throw `DualControlViolationException` if match [Source: prd.md#Story 1.7, AC 2]
  - [ ] Extract IP address from `IHttpContextAccessor` for audit trail
  - [ ] Implement `PublishApprovalAttemptEventAsync` helper method
  - [ ] Publish `LoanApprovalAttempted` audit event for ALL validation attempts (success and blocked) [Source: prd.md#Story 1.7, AC 3]
  - [ ] Add structured logging: validation start, checks performed, outcome, correlation IDs [Source: prd.md#NFR5]

- [ ] Register DualControlValidator in Program.cs
  - [ ] Add `builder.Services.AddScoped<IDualControlValidator, DualControlValidator>();` to DI container
  - [ ] Ensure `IHttpContextAccessor` registered: `builder.Services.AddHttpContextAccessor();`

- [ ] Modify LoanApplicationService.ApproveApplicationAsync (AC: 5)
  - [ ] Inject `IDualControlValidator` dependency into `LoanApplicationService` constructor
  - [ ] At start of `ApproveApplicationAsync` method, call `await _dualControlValidator.ValidateApprovalAsync(applicationId, approverUserId, cancellationToken)` [Source: prd.md#Story 1.7, AC 5]
  - [ ] If validation throws `DualControlViolationException`, allow exception to propagate to controller
  - [ ] If validation passes, proceed with existing approval logic
  - [ ] Maintain existing method signature (add `approverUserId` parameter if not present) [Source: prd.md#CR1]

- [ ] Update LoanApplicationController exception handling (AC: 6)
  - [ ] Add try-catch for `DualControlViolationException` in approval endpoint
  - [ ] Return 403 Forbidden with error code `DUAL_CONTROL_VIOLATION` [Source: prd.md#Story 1.7, AC 6]
  - [ ] Include ApplicationId, ApproverUserId, ViolationType in error response
  - [ ] Include actionable guidance message for frontend display
  - [ ] Extract approver user ID from authentication claims: `User.FindFirst(ClaimTypes.NameIdentifier)?.Value`
  - [ ] Pass approver user ID to `ApproveApplicationAsync` method

- [ ] Update BPMN workflow with excludeUsers expressions (AC: 4)
  - [ ] Open `Workflows/loan-origination-process.bpmn` in Camunda Modeler
  - [ ] Modify Credit Analyst Approval task: Add `excludeUsers="#{createdBy},#{assessedBy}"` to `zeebe:assignmentDefinition` [Source: prd.md#Story 1.7, AC 4]
  - [ ] Modify Head of Credit Approval task: Add `excludeUsers="#{createdBy},#{assessedBy}"` to `zeebe:assignmentDefinition`
  - [ ] Modify CEO Approval task: Add `excludeUsers="#{createdBy},#{assessedBy},#{firstApproverId}"` to `zeebe:assignmentDefinition`
  - [ ] Ensure workflow variables `createdBy`, `assessedBy`, `firstApproverId` set when starting workflow and completing approval tasks
  - [ ] Validate BPMN in Camunda Modeler (no validation errors)

- [ ] Modify WorkflowService to set exclusion variables
  - [ ] Update `StartLoanOriginationWorkflowAsync` to include `createdBy` and `assessedBy` in workflow variables [Source: prd.md#Story 1.5, AC 6]
  - [ ] Create method to set `firstApproverId` variable after Head of Credit approval (for dual control scenarios)
  - [ ] Ensure variables passed as JSON to Zeebe workflow instance

- [ ] Write unit tests for DualControlValidator (AC: 7)
  - [ ] Test approver == creator throws `DualControlViolationException` with violation type "SELF_APPROVAL" [Source: prd.md#Story 1.7, AC 7]
  - [ ] Test approver == assessor throws `DualControlViolationException` with violation type "APPROVER_AS_ASSESSOR" [Source: prd.md#Story 1.7, AC 7]
  - [ ] Test approver != creator AND approver != assessor → validation passes (no exception) [Source: prd.md#Story 1.7, IV1]
  - [ ] Test `LoanApprovalAttempted` event published for validation pass [Source: prd.md#Story 1.7, AC 3]
  - [ ] Test `LoanApprovalAttempted` event published for validation blocked [Source: prd.md#Story 1.7, AC 3]
  - [ ] Test IP address extraction from `IHttpContextAccessor`
  - [ ] Mock `LmsDbContext`, `IPublishEndpoint`, `IHttpContextAccessor` for unit tests

- [ ] Write integration tests with API endpoint (AC: 8)
  - [ ] Test API endpoint: Creator attempts to approve own loan → receives 403 Forbidden with error code `DUAL_CONTROL_VIOLATION` [Source: prd.md#Story 1.7, IV2, AC 8]
  - [ ] Test API endpoint: Assessor attempts to approve assessed loan → receives 403 Forbidden with error code `DUAL_CONTROL_VIOLATION` [Source: prd.md#Story 1.7, AC 8]
  - [ ] Test API endpoint: Different user approves loan → receives 200 OK (approval succeeds) [Source: prd.md#Story 1.7, IV1, AC 8]
  - [ ] Test audit event `LoanApprovalAttempted` published to RabbitMQ for all scenarios
  - [ ] Test framework: xUnit with TestContainers for SQL Server and RabbitMQ

- [ ] Write integration tests with Camunda Tasklist (AC: 8)
  - [ ] Deploy BPMN with `excludeUsers` expressions to test Camunda instance
  - [ ] Start workflow with `createdBy` and `assessedBy` variables
  - [ ] Query approval tasks for creator user → verify task NOT in their queue (filtered by excludeUsers) [Source: prd.md#Story 1.7, IV3, AC 8]
  - [ ] Query approval tasks for assessor user → verify task NOT in their queue (filtered by excludeUsers) [Source: prd.md#Story 1.7, IV3, AC 8]
  - [ ] Query approval tasks for different user → verify task IS in their queue [Source: prd.md#Story 1.7, IV1]
  - [ ] Test framework: Camunda Zeebe Process Test library with TestContainers

- [ ] Integration verification: Valid approval succeeds (IV1)
  - [ ] Create loan via API with User A (creator)
  - [ ] Attempt approval via API with User B (different user, not assessor) [Source: prd.md#Story 1.7, IV1]
  - [ ] Verify approval succeeds with 200 OK
  - [ ] Verify loan status updated to Approved
  - [ ] Verify `LoanApprovalAttempted` event published with outcome "VALIDATION_PASSED"

- [ ] Integration verification: Self-approval blocked via API (IV2)
  - [ ] Create loan via API with User A (creator)
  - [ ] Attempt approval via API with User A (same user) [Source: prd.md#Story 1.7, IV2]
  - [ ] Verify API returns 403 Forbidden with error code `DUAL_CONTROL_VIOLATION`
  - [ ] Verify error message explains "cannot approve own loan"
  - [ ] Verify loan status remains unchanged (not approved)
  - [ ] Verify `LoanApprovalAttempted` event published with outcome "BLOCKED_SELF_APPROVAL"

- [ ] Integration verification: Approver-as-assessor blocked via API
  - [ ] Create loan via API with User A (creator)
  - [ ] Perform credit assessment with User B (assessor)
  - [ ] Attempt approval via API with User B (assessor attempting approval)
  - [ ] Verify API returns 403 Forbidden with error code `DUAL_CONTROL_VIOLATION`
  - [ ] Verify error message explains "cannot approve loans assessed by same user"
  - [ ] Verify `LoanApprovalAttempted` event published with outcome "BLOCKED_APPROVER_AS_ASSESSOR"

- [ ] Integration verification: Camunda Tasklist filtering (IV3)
  - [ ] Start loan workflow with `createdBy=UserA`, `assessedBy=UserB`
  - [ ] Query approval tasks assigned to UserA (creator) in Camunda Tasklist [Source: prd.md#Story 1.7, IV3]
  - [ ] Verify task does NOT appear in UserA's task list (filtered by `excludeUsers`)
  - [ ] Query approval tasks assigned to UserB (assessor) in Camunda Tasklist
  - [ ] Verify task does NOT appear in UserB's task list (filtered by `excludeUsers`)
  - [ ] Query approval tasks assigned to UserC (different user in approver group)
  - [ ] Verify task DOES appear in UserC's task list (not excluded)

- [ ] Integration verification: Dual control scenario (IV4)
  - [ ] Create high-value loan (>250K) or high-risk loan (Grade D/F) requiring dual control
  - [ ] First approval: Head of Credit (UserX) approves loan [Source: loan-approval-workflow.md#Rule Set 3]
  - [ ] Verify workflow advances to CEO approval task
  - [ ] Verify workflow variable `firstApproverId=UserX` set
  - [ ] Second approval attempt: UserX (Head of Credit) cannot see CEO approval task (excluded via `firstApproverId`)
  - [ ] Second approval: CEO (UserY, UserY != UserX) approves loan
  - [ ] Verify loan marked as Approved after dual control completion

- [ ] Performance verification
  - [ ] Verify validation query completes within 100ms (indexed query on CreatedBy, AssessedBy) [Source: prd.md#NFR1]
  - [ ] Verify overall approval API response <500ms at p95 [Source: prd.md#NFR1]
  - [ ] Verify audit event publishing does not block API response [Source: prd.md#NFR4]

- [ ] Documentation
  - [ ] Add README section: "Dual Control Enforcement" explaining two-layer validation (Camunda + API)
  - [ ] Document approval authority matrix with exclusion rules
  - [ ] Document BPMN `excludeUsers` expression syntax and variables
  - [ ] Document `DualControlViolationException` error codes and meanings
  - [ ] Add code comments explaining dual control business rules

## Change Log

| Date       | Version | Description                      | Author |
|------------|---------|----------------------------------|--------|
| 2025-10-17 | 0.1     | Initial draft created            | SM     |

## Dev Agent Record

*(This section will be populated by the development agent during implementation)*

### Agent Model Used

*(To be filled by dev agent)*

### Debug Log References

*(To be filled by dev agent)*

### Completion Notes

*(To be filled by dev agent)*

### File List

*(To be filled by dev agent)*

## QA Results

*(To be filled by QA agent)*
