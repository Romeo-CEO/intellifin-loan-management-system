# Story 1.8: Agreement Generation Service with JasperReports Integration

Status: Draft

## Story

**As a** loan officer,  
**I want** loan agreements automatically generated and stored when loans are approved,  
**so that** I can immediately download agreements for client signature without manual document preparation.

## Acceptance Criteria

1. `AgreementGenerationService` implemented with `GenerateAgreementAsync(applicationId)` method
2. Service calls JasperReports API `POST /rest_v2/reports/intellifin/loan-agreements/{template}.pdf` with loan data JSON payload
3. Service computes SHA256 hash of generated PDF for integrity verification and tamper detection
4. Service stores PDF in MinIO at `loan-agreements/{clientId}/{loanNumber}_v{version}.pdf`
5. Service updates LoanApplication record with AgreementFileHash and AgreementMinioPath columns
6. `GenerateAgreementWorker` implemented as Zeebe job worker handling `generate-agreement` service tasks
7. Worker has 10-second timeout, throws workflow incident if JasperReports times out (manual retry by operations)
8. JasperReports template created for GEPL-001 product with basic layout (loan terms, repayment schedule, signatures)

## Integration Verification

- **IV1**: Approve loan via workflow → verify agreement generates automatically, MinIO contains PDF with correct path, database record has SHA256 hash
- **IV2**: Download agreement via API `/api/loanapplication/{id}/agreement` → verify PDF content matches loan terms, amounts, and schedules
- **IV3**: Simulate JasperReports timeout (>10 seconds) → verify workflow incident created in Camunda, approval not rolled back (loan still approved, agreement retry-able)
- **IV4**: Verify agreement immutability → attempt to modify PDF in MinIO → verify WORM storage prevents modification

## Dev Notes

### Previous Story Insights
- Story 1.2 implemented LoanVersioningService with loan number generation and version tracking
- Story 1.3 integrated Vault for product configurations (provides template version and EAR data)
- Story 1.5 designed and deployed Camunda BPMN workflow with service tasks
- Story 1.6 implemented KycVerificationWorker demonstrating job worker pattern
- Story 1.7 implemented DualControlValidator - approval must succeed before agreement generation
- Existing `LoanApplicationModels` has `AgreementFileHash` and `AgreementMinioPath` columns from Story 1.1 schema migration [Source: brownfield-architecture.md#Data Architecture Changes, lines 1363-1365]

### Current State Problem [Sources]

**Missing Agreement Generation** - No automated document creation
- Architecture document identifies this as critical gap [Source: brownfield-architecture.md#❌ 5. Agreement Generation with JasperReports, lines 724-868]
- Current state: No JasperReports integration exists [Source: prd.md#1.2 What is MISSING, line 47]
- No document storage in MinIO for agreements [Source: brownfield-architecture.md#Current State Analysis]
- No cryptographic hashing for document integrity [Source: prd.md#1.2 What is MISSING]

**Regulatory Requirement**: Bank of Zambia requires documented loan agreements with complete terms, stored securely with audit trails [Source: prd.md#1.4 Background Context; loan-documentation.md#Regulatory Compliance]

**Business Impact**: Manual agreement preparation causes 24-48 hour delays in disbursement [Source: prd.md#1.4 Goals - automate agreement generation for sub-24-hour processing]

### AgreementGenerationService Implementation [Sources]

**Service Pattern**:
```csharp
public class AgreementGenerationService : IAgreementGenerationService
{
    private readonly HttpClient _jasperClient;
    private readonly IMinioClient _minioClient;
    private readonly LmsDbContext _dbContext;
    private readonly IPublishEndpoint _publishEndpoint;
    private readonly IVaultProductConfigService _vaultProductConfigService;
    private readonly ILogger<AgreementGenerationService> _logger;
    
    public async Task<AgreementDocument> GenerateAgreementAsync(
        Guid applicationId, 
        CancellationToken cancellationToken)
    {
        _logger.LogInformation(
            "Generating agreement for loan application {ApplicationId}",
            applicationId);
        
        // Fetch loan application with all required data
        var application = await _dbContext.LoanApplications
            .Include(la => la.CreditAssessment)
            .Include(la => la.Client)
            .FirstOrDefaultAsync(la => la.Id == applicationId, cancellationToken);
        
        if (application == null)
        {
            throw new NotFoundException($"Loan application {applicationId} not found");
        }
        
        // Fetch product configuration from Vault for template version and EAR
        var product = await _vaultProductConfigService
            .GetProductConfigAsync(application.ProductCode, cancellationToken);
        
        // Prepare JSON payload for JasperReports template
        var jasperPayload = new
        {
            loanNumber = application.LoanNumber,
            clientName = application.Client.FullName,
            clientNrc = application.Client.NationalIdNumber,
            clientAddress = application.Client.Address,
            principal = application.RequestedAmount,
            termMonths = application.TermMonths,
            interestRate = product.BaseInterestRate,
            adminFee = product.AdminFee,
            managementFee = product.ManagementFee,
            calculatedEAR = product.CalculatedEAR,
            monthlyPayment = CalculateMonthlyPayment(
                application.RequestedAmount, 
                product.BaseInterestRate, 
                application.TermMonths),
            repaymentSchedule = GenerateRepaymentSchedule(application, product),
            disbursementDate = DateTime.UtcNow,
            agreementDate = DateTime.UtcNow,
            templateVersion = product.AgreementTemplateVersion ?? "GEPL-v1.0"
        };
        
        // Determine template path based on product code
        var templatePath = GetTemplatePath(application.ProductCode);
        
        // Call JasperReports Server API
        var jasperUrl = $"/rest_v2/reports/intellifin/loan-agreements/{templatePath}.pdf";
        
        _logger.LogInformation(
            "Calling JasperReports API: {JasperUrl} for loan {LoanNumber}",
            jasperUrl, application.LoanNumber);
        
        var response = await _jasperClient.PostAsJsonAsync(
            jasperUrl,
            jasperPayload,
            cancellationToken);
        
        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync(cancellationToken);
            _logger.LogError(
                "JasperReports generation failed for loan {LoanNumber}. Status: {StatusCode}, Error: {Error}",
                application.LoanNumber, response.StatusCode, errorContent);
            
            throw new AgreementGenerationException(
                $"JasperReports generation failed: {response.StatusCode}");
        }
        
        // Read PDF bytes from response
        var pdfBytes = await response.Content.ReadAsByteArrayAsync(cancellationToken);
        
        _logger.LogInformation(
            "JasperReports generated PDF for loan {LoanNumber}, size: {Size} bytes",
            application.LoanNumber, pdfBytes.Length);
        
        // Calculate SHA256 hash for integrity verification
        var documentHash = ComputeSha256Hash(pdfBytes);
        
        // Store PDF in MinIO
        var minioPath = $"loan-agreements/{application.ClientId}/{application.LoanNumber}_v{application.Version}.pdf";
        
        await _minioClient.PutObjectAsync(new PutObjectArgs()
            .WithBucket("intellifin-documents")
            .WithObject(minioPath)
            .WithStreamData(new MemoryStream(pdfBytes))
            .WithContentType("application/pdf")
            .WithObjectSize(pdfBytes.Length),
            cancellationToken);
        
        _logger.LogInformation(
            "Agreement PDF stored in MinIO at {MinioPath} for loan {LoanNumber}",
            minioPath, application.LoanNumber);
        
        // Update loan application record with agreement details
        application.AgreementFileHash = documentHash;
        application.AgreementMinioPath = minioPath;
        application.AgreementGeneratedAt = DateTime.UtcNow;
        
        await _dbContext.SaveChangesAsync(cancellationToken);
        
        // Publish audit event to AdminService
        await _publishEndpoint.Publish(new LoanAgreementGenerated
        {
            LoanApplicationId = applicationId,
            LoanNumber = application.LoanNumber,
            ClientId = application.ClientId,
            DocumentHash = documentHash,
            MinioPath = minioPath,
            TemplateVersion = product.AgreementTemplateVersion ?? "GEPL-v1.0",
            GeneratedAt = DateTime.UtcNow,
            GeneratedBy = "SYSTEM", // Could use IUserContextProvider if available
            CorrelationId = Guid.NewGuid()
        }, cancellationToken);
        
        _logger.LogInformation(
            "Agreement generation completed successfully for loan {LoanNumber}",
            application.LoanNumber);
        
        return new AgreementDocument
        {
            LoanNumber = application.LoanNumber,
            FileHash = documentHash,
            MinioPath = minioPath,
            GeneratedAt = DateTime.UtcNow
        };
    }
    
    private string ComputeSha256Hash(byte[] data)
    {
        using var sha256 = SHA256.Create();
        var hashBytes = sha256.ComputeHash(data);
        return Convert.ToHexString(hashBytes);
    }
    
    private string GetTemplatePath(string productCode)
    {
        return productCode switch
        {
            "GEPL-001" => "gepl-agreement",
            "SMEABL-001" => "smeabl-agreement",
            _ => throw new InvalidOperationException($"No template configured for product {productCode}")
        };
    }
    
    private decimal CalculateMonthlyPayment(decimal principal, decimal annualRate, int termMonths)
    {
        var monthlyRate = annualRate / 12m;
        if (monthlyRate == 0) return principal / termMonths;
        
        var payment = principal * (monthlyRate * (decimal)Math.Pow((double)(1 + monthlyRate), termMonths)) 
            / ((decimal)Math.Pow((double)(1 + monthlyRate), termMonths) - 1);
        
        return Math.Round(payment, 2);
    }
    
    private List<RepaymentScheduleEntry> GenerateRepaymentSchedule(
        LoanApplication application, 
        LoanProductConfig product)
    {
        var schedule = new List<RepaymentScheduleEntry>();
        var balance = application.RequestedAmount;
        var monthlyPayment = CalculateMonthlyPayment(
            application.RequestedAmount, 
            product.BaseInterestRate, 
            application.TermMonths);
        var dueDate = DateTime.UtcNow.AddMonths(1);
        
        for (int month = 1; month <= application.TermMonths; month++)
        {
            var interestPayment = balance * (product.BaseInterestRate / 12m);
            var principalPayment = monthlyPayment - interestPayment;
            balance -= principalPayment;
            
            schedule.Add(new RepaymentScheduleEntry
            {
                Month = month,
                DueDate = dueDate,
                PrincipalPayment = Math.Round(principalPayment, 2),
                InterestPayment = Math.Round(interestPayment, 2),
                TotalPayment = Math.Round(monthlyPayment, 2),
                Balance = Math.Round(Math.Max(balance, 0), 2)
            });
            
            dueDate = dueDate.AddMonths(1);
        }
        
        return schedule;
    }
}
```
[Source: brownfield-architecture.md#❌ 5. Agreement Generation with JasperReports, lines 730-818 - pattern adapted with complete implementation]

### GenerateAgreementWorker Implementation [Sources]

**Zeebe Job Worker Pattern**:
```csharp
public class GenerateAgreementWorker : BackgroundService
{
    private readonly IZeebeClient _zeebeClient;
    private readonly IAgreementGenerationService _agreementService;
    private readonly ILogger<GenerateAgreementWorker> _logger;
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Register job worker for "generate-agreement" task type
        await _zeebeClient.NewWorker()
            .JobType("generate-agreement")
            .Handler(HandleAgreementGenerationAsync)
            .MaxJobsActive(5) // Process up to 5 agreement generations concurrently
            .Name("agreement-generation-worker")
            .AutoComplete(false) // Manual completion after generation
            .PollInterval(TimeSpan.FromSeconds(1))
            .Timeout(TimeSpan.FromSeconds(10)) // 10-second timeout for JasperReports call
            .Open();
        
        // Keep service running
        await Task.Delay(Timeout.Infinite, stoppingToken);
    }
    
    private async Task HandleAgreementGenerationAsync(
        IJobClient jobClient, 
        IJob job)
    {
        var applicationId = Guid.Parse(job.Variables["applicationId"].ToString());
        
        _logger.LogInformation(
            "Processing agreement generation for application {ApplicationId}, Job Key: {JobKey}",
            applicationId, job.Key);
        
        try
        {
            // Generate agreement document
            var agreement = await _agreementService.GenerateAgreementAsync(
                applicationId, CancellationToken.None);
            
            // Complete job with agreement details as workflow variables
            await jobClient.NewCompleteCommand(job.Key)
                .Variables(JsonSerializer.Serialize(new 
                {
                    agreementGenerated = true,
                    agreementHash = agreement.FileHash,
                    minioPath = agreement.MinioPath,
                    generatedAt = agreement.GeneratedAt.ToString("o")
                }))
                .Send();
            
            _logger.LogInformation(
                "Agreement generation completed successfully for application {ApplicationId}, Loan: {LoanNumber}",
                applicationId, agreement.LoanNumber);
        }
        catch (AgreementGenerationException ex)
        {
            // JasperReports generation failed - throw workflow error for incident
            _logger.LogError(ex,
                "Agreement generation failed for application {ApplicationId}",
                applicationId);
            
            await jobClient.NewThrowErrorCommand(job.Key)
                .ErrorCode("AGREEMENT_GENERATION_FAILED")
                .ErrorMessage($"JasperReports generation failed: {ex.Message}")
                .Send();
        }
        catch (Exception ex)
        {
            // Unexpected error - fail job with retry
            _logger.LogError(ex,
                "Unexpected error during agreement generation for application {ApplicationId}",
                applicationId);
            
            await jobClient.NewFailCommand(job.Key)
                .Retries(job.Retries - 1) // Decrement retries
                .ErrorMessage($"Unexpected error: {ex.Message}")
                .Send();
        }
    }
}
```
[Source: brownfield-architecture.md#Worker Implementation, lines 830-860 - pattern adapted for agreement generation]

### JasperReports API Integration [Sources]

**API Endpoint**: `POST /rest_v2/reports/intellifin/loan-agreements/{template}.pdf`
**Authentication**: Basic Authentication or OAuth2 (configured in JasperReports Server) [Source: prd.md#4.2 API Integration Strategy]
**Timeout**: 10 seconds with single retry [Source: prd.md#Story 1.8, AC 7; prd.md#NFR8]
**Content-Type**: `application/json` (request), `application/pdf` (response)

**Request Payload Example**:
```json
{
  "loanNumber": "LUS-2025-00123",
  "clientName": "John Banda",
  "clientNrc": "123456/78/9",
  "clientAddress": "Plot 123, Lusaka Road, Lusaka",
  "principal": 50000.00,
  "termMonths": 24,
  "interestRate": 0.12,
  "adminFee": 0.02,
  "managementFee": 0.01,
  "calculatedEAR": 0.152,
  "monthlyPayment": 2356.25,
  "repaymentSchedule": [
    {
      "month": 1,
      "dueDate": "2025-11-17",
      "principalPayment": 1856.25,
      "interestPayment": 500.00,
      "totalPayment": 2356.25,
      "balance": 48143.75
    }
  ],
  "disbursementDate": "2025-10-17",
  "agreementDate": "2025-10-17",
  "templateVersion": "GEPL-v1.0"
}
```
[Source: brownfield-architecture.md#❌ 5. Agreement Generation with JasperReports, lines 746-758]

### MinIO Storage Configuration [Sources]

**Bucket**: `intellifin-documents`
**Path Pattern**: `loan-agreements/{clientId}/{loanNumber}_v{version}.pdf`
**Content-Type**: `application/pdf`
**Storage Class**: WORM (Write Once Read Many) for immutability [Source: brownfield-architecture.md#3. Document Integrity, lines 1497-1502]

**MinIO Client Configuration**:
```csharp
// Program.cs
builder.Services.AddSingleton<IMinioClient>(provider => {
    var configuration = provider.GetRequiredService<IConfiguration>();
    return new MinioClient()
        .WithEndpoint(configuration["MinIO:Endpoint"])
        .WithCredentials(
            configuration["MinIO:AccessKey"], 
            configuration["MinIO:SecretKey"])
        .WithSSL(bool.Parse(configuration["MinIO:UseSSL"] ?? "true"))
        .Build();
});
```
[Source: brownfield-architecture.md#❌ 5. Agreement Generation with JasperReports, line 866 - MinIO client setup]

### Document Integrity - SHA256 Hashing [Sources]

**Hash Algorithm**: SHA256 (produces 64-character hex string)
**Purpose**: Document integrity verification and tamper detection [Source: brownfield-architecture.md#3. Document Integrity, lines 1497-1502]
**Storage**: Hash stored in `LoanApplications.AgreementFileHash` column AND published in audit event

**Hash Implementation**:
```csharp
private string ComputeSha256Hash(byte[] data)
{
    using var sha256 = SHA256.Create();
    var hashBytes = sha256.ComputeHash(data);
    return Convert.ToHexString(hashBytes); // Produces uppercase hex string
}
```
[Source: brownfield-architecture.md#❌ 5. Agreement Generation with JasperReports, lines 812-817]

**Hash Verification** (for future implementation):
- When downloading agreement, recompute hash and compare with stored value
- If hashes don't match, document has been tampered with → alert compliance team

### Domain Models [Sources]

**AgreementDocument** (returned from service):
```csharp
public class AgreementDocument
{
    public string LoanNumber { get; set; }
    public string FileHash { get; set; }
    public string MinioPath { get; set; }
    public DateTime GeneratedAt { get; set; }
}
```

**RepaymentScheduleEntry** (used in agreement payload):
```csharp
public class RepaymentScheduleEntry
{
    public int Month { get; set; }
    public DateTime DueDate { get; set; }
    public decimal PrincipalPayment { get; set; }
    public decimal InterestPayment { get; set; }
    public decimal TotalPayment { get; set; }
    public decimal Balance { get; set; }
}
```

### Event Schema [Sources]

**LoanAgreementGenerated Event** (published to AdminService):
```csharp
public class LoanAgreementGenerated
{
    public Guid LoanApplicationId { get; set; }
    public string LoanNumber { get; set; }
    public Guid ClientId { get; set; }
    public string DocumentHash { get; set; }
    public string MinioPath { get; set; }
    public string TemplateVersion { get; set; }
    public DateTime GeneratedAt { get; set; }
    public string GeneratedBy { get; set; } // User ID or "SYSTEM"
    public Guid CorrelationId { get; set; }
}
```
[Source: brownfield-architecture.md#❌ 5. Agreement Generation with JasperReports, lines 792-801; prd.md#FR9]

### Domain Exceptions [Sources]

**AgreementGenerationException** - Thrown when JasperReports generation fails
```csharp
public class AgreementGenerationException : Exception
{
    public Guid ApplicationId { get; }
    public string TemplatePath { get; }
    
    public AgreementGenerationException(string message) 
        : base(message)
    {
    }
    
    public AgreementGenerationException(Guid applicationId, string templatePath, string message, Exception innerException)
        : base(message, innerException)
    {
        ApplicationId = applicationId;
        TemplatePath = templatePath;
    }
}
```
[Source: brownfield-architecture.md#❌ 5. Agreement Generation with JasperReports, line 768; brownfield-architecture.md#4.3 Exception handling]

### Database Schema Updates [Sources]

**Add AgreementGeneratedAt column**:
```sql
ALTER TABLE LoanApplications 
ADD AgreementGeneratedAt DATETIME2 NULL;
```

**Existing columns from Story 1.1**:
- `AgreementFileHash` (NVARCHAR(64))
- `AgreementMinioPath` (NVARCHAR(500))
[Source: brownfield-architecture.md#Data Architecture Changes, lines 1405-1406]

### JasperReports Template Requirements [Sources]

**Template File**: `gepl-agreement.jrxml` (for GEPL-001 product)
**Template Location**: Separate repository under version control [Source: brownfield-architecture.md#4. Agreement Templates Not Created, lines 1459-1465]
**Template Components**:
- **Header**: IntelliFin logo, company details, agreement date
- **Client Details**: Name, NRC, address
- **Loan Terms**: Principal, term, interest rate, EAR, monthly payment
- **Repayment Schedule**: Table with all payment details
- **Terms and Conditions**: Legal text from legal counsel
- **Signatures**: Client signature, witness signature, company officer signature

**Template Versioning**: Template version tracked in Vault product config (`agreementTemplateVersion`) [Source: brownfield-architecture.md#❌ 5. Agreement Generation with JasperReports, lines 757, 798]

**Template Approval Workflow**: Dual control required for template changes (compliance + legal approval) [Source: brownfield-architecture.md#4. Agreement Templates Not Created, line 1465]

### File Locations [Sources]

- **New Service**: `apps/IntelliFin.LoanOriginationService/Services/AgreementGenerationService.cs` [NEW]
- **New Interface**: `apps/IntelliFin.LoanOriginationService/Services/IAgreementGenerationService.cs` [NEW]
- **New Worker**: `apps/IntelliFin.LoanOriginationService/Workers/GenerateAgreementWorker.cs` [NEW]
- **New Models**: `apps/IntelliFin.LoanOriginationService/Models/AgreementDocument.cs` [NEW]
- **New Models**: `apps/IntelliFin.LoanOriginationService/Models/RepaymentScheduleEntry.cs` [NEW]
- **New Exception**: `apps/IntelliFin.LoanOriginationService/Exceptions/AgreementGenerationException.cs` [NEW]
- **New Event Model**: `apps/IntelliFin.LoanOriginationService/Events/LoanAgreementGenerated.cs` [NEW]
- **Modify Entity**: `apps/IntelliFin.LoanOriginationService/Models/LoanApplicationModels.cs` - Add `AgreementGeneratedAt` property [MODIFY]
- **New Controller Method**: `apps/IntelliFin.LoanOriginationService/Controllers/LoanApplicationController.cs` - Add `DownloadAgreement` endpoint [MODIFY]
- **Modify BPMN**: `apps/IntelliFin.LoanOriginationService/Workflows/loan-origination-process.bpmn` - Verify `generate-agreement` service task exists [NO CHANGE - already created in Story 1.5]
- **New Template**: Separate repository for JasperReports templates: `gepl-agreement.jrxml` [NEW - external repo]
[Source: brownfield-architecture.md#❌ 5. Agreement Generation with JasperReports, lines 862-868; brownfield-architecture.md#4.3 Code Organization]

### Technology Stack [Sources]

**JasperReports Integration**: HttpClient with typed client pattern
- Base URL configured in `appsettings.json`: `JasperReports:BaseUrl`
- Authentication: Basic or OAuth2 configured in HTTP handler
- Timeout: 10 seconds [Source: prd.md#Story 1.8, AC 7]

**MinIO Client**: Minio.AspNetCore NuGet package
- SDK version: 6.0+ compatible with .NET 9
- Configuration: Endpoint, AccessKey, SecretKey from appsettings or Vault

**SHA256 Hashing**: System.Security.Cryptography (built-in .NET)

**PDF Generation**: JasperReports Server 8.0+ [Source: prd.md#4.1 Existing Technology Stack]

**Audit Events**: MassTransit with RabbitMQ (already configured)
- Publish `LoanAgreementGenerated` events to `intellifin.loan.events` exchange
[Source: brownfield-architecture.md#✅ Service Scaffolding and Infrastructure, lines 215-218]

### Coding Standards [Sources]

- **Async/await**: All I/O operations async with CancellationToken propagation [Source: brownfield-architecture.md#4.3 Coding Standards]
- **Structured logging**: Use Serilog with correlation IDs for JasperReports API calls, MinIO operations, agreement generation events [Source: brownfield-architecture.md#4.3 Coding Standards]
- **Exception handling**: Domain exception (`AgreementGenerationException`) for JasperReports failures; infrastructure exceptions for MinIO failures [Source: brownfield-architecture.md#4.3 Coding Standards]
- **Timeout handling**: 10-second timeout for JasperReports with workflow incident on failure [Source: prd.md#Story 1.8, AC 7]
- **XML comments**: Required for all public interfaces and service classes [Source: brownfield-architecture.md#4.3 Documentation Standards]

### Testing Requirements [Sources]

**Unit Tests (xUnit)**
- Test `GenerateAgreementAsync` creates PDF, computes hash, stores in MinIO, updates database [Source: prd.md#Story 1.8, AC 1-5]
- Test SHA256 hash computation produces consistent 64-character hex string
- Test template path selection for different product codes (GEPL-001, SMEABL-001)
- Test repayment schedule calculation (principal, interest, balance)
- Test monthly payment calculation with various interest rates and terms
- Test `AgreementGenerationException` thrown when JasperReports returns error
- Mock `HttpClient`, `IMinioClient`, `LmsDbContext`, `IPublishEndpoint` for unit tests

**Integration Tests**
- Test JasperReports API integration with real template (or test template) [Source: prd.md#Story 1.8, AC 2]
- Test MinIO storage: upload PDF, verify file exists, download and verify content [Source: prd.md#Story 1.8, AC 4]
- Test workflow worker: start workflow, approve loan, verify agreement generated automatically [Source: prd.md#Story 1.8, IV1]
- Test timeout scenario: simulate slow JasperReports response (>10s), verify workflow incident [Source: prd.md#Story 1.8, AC 7, IV3]
- Test agreement download API endpoint: verify PDF retrieved from MinIO [Source: prd.md#Story 1.8, IV2]
- Test audit event published to RabbitMQ with correct hash and MinIO path
- Test framework: xUnit with TestContainers for MinIO, RabbitMQ [Source: prd.md#4.2 Testing Integration Strategy]

**Template Validation**
- Create basic `.jrxml` template for GEPL-001 with test data [Source: prd.md#Story 1.8, AC 8]
- Deploy template to JasperReports Server (development environment)
- Test template rendering with sample loan data
- Verify all required fields populated correctly
- Verify repayment schedule table renders properly

### Performance Constraints [Sources]

- JasperReports PDF generation must complete within 3 seconds at p95 [Source: prd.md#NFR8]
- Worker timeout set to 10 seconds to allow for retry attempts [Source: prd.md#Story 1.8, AC 7]
- MinIO upload must complete within 2 seconds for 1MB PDF
- Overall agreement generation (JasperReports + MinIO + database update) must complete within 5 seconds
- Worker can handle up to 5 concurrent agreement generations (MaxJobsActive = 5)
- Correlation IDs must be propagated for distributed tracing [Source: prd.md#NFR5]

### User Experience Requirements [Sources]

**Agreement Download Endpoint**:
```csharp
[HttpGet("{id}/agreement")]
public async Task<IActionResult> DownloadAgreement(
    Guid id,
    CancellationToken cancellationToken)
{
    var application = await _dbContext.LoanApplications
        .FirstOrDefaultAsync(la => la.Id == id, cancellationToken);
    
    if (application == null)
        return NotFound("Loan application not found");
    
    if (string.IsNullOrEmpty(application.AgreementMinioPath))
        return NotFound("Agreement not yet generated");
    
    // Download from MinIO
    var stream = new MemoryStream();
    await _minioClient.GetObjectAsync(new GetObjectArgs()
        .WithBucket("intellifin-documents")
        .WithObject(application.AgreementMinioPath)
        .WithCallbackStream(s => s.CopyTo(stream)),
        cancellationToken);
    
    stream.Position = 0;
    
    return File(stream, "application/pdf", $"{application.LoanNumber}_Agreement.pdf");
}
```
[Source: prd.md#Story 1.8, IV2]

**Workflow Incident Handling**:
- If JasperReports times out, workflow creates incident visible in Camunda Cockpit
- Operations team can retry incident manually after investigating timeout
- Loan approval is NOT rolled back - loan remains approved, only agreement generation pending [Source: prd.md#Story 1.8, IV3]

### Dependencies
- **Story 1.2**: Loan number generation and versioning (provides LoanNumber and Version for file path) [Source: prd.md#Story 1.8 Dependencies]
- **Story 1.3**: Vault product configuration (provides template version and EAR data) [Source: prd.md#Story 1.8 Dependencies]
- **Story 1.7**: Dual control approval must succeed before agreement generation [Source: prd.md#Story 1.8 Dependencies]
- **JasperReports Server**: Operational with templates deployed [Source: prd.md#4.1 Existing Technology Stack]
- **MinIO**: Operational with `intellifin-documents` bucket created [Source: prd.md#4.1 Existing Technology Stack]

## Tasks / Subtasks

- [ ] Add database migration for AgreementGeneratedAt column
  - [ ] Create migration: Add `AgreementGeneratedAt` (DATETIME2 NULL) to LoanApplications table
  - [ ] Update `LoanApplicationModels.cs` with `AgreementGeneratedAt` property
  - [ ] Run migration and verify schema changes

- [ ] Create domain models (AC: 1)
  - [ ] Create `Models/AgreementDocument.cs` with properties: LoanNumber, FileHash, MinioPath, GeneratedAt
  - [ ] Create `Models/RepaymentScheduleEntry.cs` with properties: Month, DueDate, PrincipalPayment, InterestPayment, TotalPayment, Balance
  - [ ] Add XML documentation comments for all properties

- [ ] Create domain exception
  - [ ] Create `Exceptions/AgreementGenerationException.cs` with ApplicationId, TemplatePath properties
  - [ ] Add constructors for different failure scenarios (JasperReports failure, MinIO failure)
  - [ ] Add XML documentation comments

- [ ] Create event model
  - [ ] Create `Events/LoanAgreementGenerated.cs` with properties: LoanApplicationId, LoanNumber, ClientId, DocumentHash, MinioPath, TemplateVersion, GeneratedAt, GeneratedBy, CorrelationId
  - [ ] Add XML documentation comments for all event properties

- [ ] Create IAgreementGenerationService interface (AC: 1)
  - [ ] Define `Task<AgreementDocument> GenerateAgreementAsync(Guid applicationId, CancellationToken cancellationToken)` signature
  - [ ] Add XML documentation comments explaining agreement generation process

- [ ] Install required NuGet packages
  - [ ] Add `Minio` package (version 6.0+) for MinIO client
  - [ ] Verify System.Security.Cryptography available (built-in .NET)
  - [ ] Verify packages compatible with .NET 9

- [ ] Implement AgreementGenerationService (AC: 1, 2, 3, 4, 5)
  - [ ] Create `Services/AgreementGenerationService.cs` implementing `IAgreementGenerationService`
  - [ ] Inject `HttpClient`, `IMinioClient`, `LmsDbContext`, `IPublishEndpoint`, `IVaultProductConfigService`, `ILogger<AgreementGenerationService>` dependencies
  - [ ] Implement `GenerateAgreementAsync` method
  - [ ] Fetch loan application with client and assessment data (Include navigation properties) [Source: prd.md#Story 1.8, AC 1]
  - [ ] Fetch product configuration from Vault for template version and EAR [Source: Story 1.3 integration]
  - [ ] Prepare JSON payload for JasperReports with all required fields [Source: brownfield-architecture.md#❌ 5. Agreement Generation, lines 746-758]
  - [ ] Call JasperReports API `POST /rest_v2/reports/intellifin/loan-agreements/{template}.pdf` [Source: prd.md#Story 1.8, AC 2]
  - [ ] Handle JasperReports API errors → throw `AgreementGenerationException`
  - [ ] Read PDF bytes from response
  - [ ] Compute SHA256 hash using `ComputeSha256Hash` method [Source: prd.md#Story 1.8, AC 3]
  - [ ] Store PDF in MinIO at `loan-agreements/{clientId}/{loanNumber}_v{version}.pdf` [Source: prd.md#Story 1.8, AC 4]
  - [ ] Update LoanApplication record with AgreementFileHash, AgreementMinioPath, AgreementGeneratedAt [Source: prd.md#Story 1.8, AC 5]
  - [ ] Publish `LoanAgreementGenerated` audit event to AdminService
  - [ ] Implement helper methods: `ComputeSha256Hash`, `GetTemplatePath`, `CalculateMonthlyPayment`, `GenerateRepaymentSchedule`
  - [ ] Add structured logging: API calls, PDF generation, MinIO storage, correlation IDs [Source: prd.md#NFR5]

- [ ] Configure HttpClient for JasperReports (AC: 2)
  - [ ] Register typed client: `services.AddHttpClient<IAgreementGenerationService, AgreementGenerationService>()`
  - [ ] Configure base address from appsettings: `JasperReports:BaseUrl`
  - [ ] Add timeout policy: 10 seconds [Source: prd.md#Story 1.8, AC 7]
  - [ ] Add authentication handler (Basic or OAuth2) based on JasperReports Server configuration
  - [ ] Add retry policy: Single retry on transient failures

- [ ] Configure MinIO client (AC: 4)
  - [ ] Register MinIO client as singleton in DI container
  - [ ] Configure endpoint, access key, secret key from appsettings or Vault
  - [ ] Verify `intellifin-documents` bucket exists (create if not)
  - [ ] Configure WORM (Write Once Read Many) policy for immutability [Source: brownfield-architecture.md#3. Document Integrity]

- [ ] Implement GenerateAgreementWorker (AC: 6, 7)
  - [ ] Create `Workers/GenerateAgreementWorker.cs` inheriting from `BackgroundService`
  - [ ] Inject `IZeebeClient`, `IAgreementGenerationService`, `ILogger<GenerateAgreementWorker>` dependencies
  - [ ] Implement `ExecuteAsync` to register Zeebe worker for `generate-agreement` job type [Source: brownfield-architecture.md#Worker Implementation, lines 830-860]
  - [ ] Configure worker: `MaxJobsActive(5)`, `AutoComplete(false)`, `Timeout(10 seconds)`, `PollInterval(1 second)` [Source: prd.md#Story 1.8, AC 7]
  - [ ] Implement `HandleAgreementGenerationAsync` handler method
  - [ ] Extract `applicationId` from job variables
  - [ ] Call `_agreementService.GenerateAgreementAsync(applicationId)` [Source: prd.md#Story 1.8, AC 1]
  - [ ] Complete job with workflow variables: `agreementGenerated: true`, `agreementHash`, `minioPath`, `generatedAt` [Source: prd.md#Story 1.8, AC 6]
  - [ ] Handle `AgreementGenerationException` → throw workflow error with code `AGREEMENT_GENERATION_FAILED` [Source: prd.md#Story 1.8, AC 7]
  - [ ] Handle unexpected exceptions → fail job with retry
  - [ ] Add structured logging: job start, completion, errors, correlation IDs

- [ ] Register worker in Program.cs
  - [ ] Add `builder.Services.AddHostedService<GenerateAgreementWorker>();` to register worker
  - [ ] Verify Zeebe client already registered from Story 1.5

- [ ] Create agreement download API endpoint (IV2)
  - [ ] Add `[HttpGet("{id}/agreement")]` method to `LoanApplicationController`
  - [ ] Query loan application, check if AgreementMinioPath exists
  - [ ] Download PDF from MinIO using `IMinioClient.GetObjectAsync`
  - [ ] Return PDF as File result with content-type `application/pdf` [Source: prd.md#Story 1.8, IV2]
  - [ ] Add error handling for missing agreements (404 Not Found)
  - [ ] Add authorization check (ensure user has permission to download loan agreement)

- [ ] Create basic JasperReports template for GEPL-001 (AC: 8)
  - [ ] Design `gepl-agreement.jrxml` template using Jasper Studio
  - [ ] Include sections: Header, Client Details, Loan Terms, Repayment Schedule, Terms & Conditions, Signatures [Source: Template Requirements section]
  - [ ] Configure template to accept JSON parameters from payload
  - [ ] Add repayment schedule table (subreport or table component)
  - [ ] Test template rendering with sample data
  - [ ] Deploy template to JasperReports Server (development environment)
  - [ ] Document template version as "GEPL-v1.0" in Vault product config [Source: Story 1.3 Vault integration]

- [ ] Write unit tests for AgreementGenerationService
  - [ ] Test `GenerateAgreementAsync` calls JasperReports API with correct payload [Source: prd.md#Story 1.8, AC 2]
  - [ ] Test SHA256 hash computation produces 64-character hex string [Source: prd.md#Story 1.8, AC 3]
  - [ ] Test MinIO storage: verify `PutObjectAsync` called with correct path [Source: prd.md#Story 1.8, AC 4]
  - [ ] Test database update: verify AgreementFileHash, AgreementMinioPath, AgreementGeneratedAt set [Source: prd.md#Story 1.8, AC 5]
  - [ ] Test `LoanAgreementGenerated` event published with correct data
  - [ ] Test `AgreementGenerationException` thrown when JasperReports returns error
  - [ ] Test template path selection for GEPL-001 and SMEABL-001
  - [ ] Test monthly payment calculation with various scenarios
  - [ ] Test repayment schedule generation (verify principal, interest, balance calculations)
  - [ ] Mock `HttpClient`, `IMinioClient`, `LmsDbContext`, `IPublishEndpoint`, `IVaultProductConfigService`

- [ ] Write unit tests for GenerateAgreementWorker
  - [ ] Test worker completes job with agreement details when generation succeeds [Source: prd.md#Story 1.8, AC 6]
  - [ ] Test worker throws workflow error when `AgreementGenerationException` occurs [Source: prd.md#Story 1.8, AC 7]
  - [ ] Test worker fails job with retry when unexpected exception occurs
  - [ ] Mock `IZeebeClient`, `IAgreementGenerationService`

- [ ] Write integration tests with JasperReports
  - [ ] Set up test JasperReports Server or use WireMock to mock API
  - [ ] Test agreement generation: create loan, approve, trigger worker, verify PDF generated [Source: prd.md#Story 1.8, IV1]
  - [ ] Test JasperReports API integration: send real payload, verify PDF returned [Source: prd.md#Story 1.8, AC 2]
  - [ ] Test timeout scenario: simulate slow JasperReports response (>10s), verify workflow incident created [Source: prd.md#Story 1.8, IV3]
  - [ ] Test framework: xUnit with TestContainers for MinIO, RabbitMQ

- [ ] Write integration tests with MinIO
  - [ ] Set up TestContainers for MinIO
  - [ ] Test PDF upload to MinIO: verify file stored at correct path [Source: prd.md#Story 1.8, AC 4, IV1]
  - [ ] Test PDF download from MinIO: verify content matches original
  - [ ] Test WORM storage: attempt to modify PDF, verify operation blocked [Source: prd.md#Story 1.8, IV4]
  - [ ] Test agreement download API endpoint: verify PDF retrieved correctly [Source: prd.md#Story 1.8, IV2]

- [ ] Integration verification: Agreement generation on approval (IV1)
  - [ ] Start loan workflow, complete all steps up to approval
  - [ ] Approve loan (trigger agreement generation automatically)
  - [ ] Verify workflow advances to `generate-agreement` service task
  - [ ] Verify agreement PDF generated and stored in MinIO at correct path [Source: prd.md#Story 1.8, IV1]
  - [ ] Verify database record updated with SHA256 hash and MinIO path
  - [ ] Verify `LoanAgreementGenerated` event published to AdminService

- [ ] Integration verification: Agreement download (IV2)
  - [ ] Generate agreement for approved loan
  - [ ] Call `/api/loanapplication/{id}/agreement` endpoint [Source: prd.md#Story 1.8, IV2]
  - [ ] Verify PDF downloaded successfully
  - [ ] Verify PDF content matches loan terms (principal, term, rate, schedule)
  - [ ] Verify repayment schedule table populated correctly

- [ ] Integration verification: JasperReports timeout (IV3)
  - [ ] Configure JasperReports Server to simulate slow response (>10 seconds)
  - [ ] Approve loan to trigger agreement generation
  - [ ] Verify workflow incident created with error code `AGREEMENT_GENERATION_FAILED` [Source: prd.md#Story 1.8, IV3]
  - [ ] Verify loan status remains "Approved" (approval not rolled back)
  - [ ] Verify incident visible in Camunda Cockpit
  - [ ] Manually retry incident from Camunda Cockpit, verify successful on retry

- [ ] Integration verification: MinIO immutability (IV4)
  - [ ] Generate agreement PDF and store in MinIO
  - [ ] Attempt to modify PDF in MinIO using PutObject with same path [Source: prd.md#Story 1.8, IV4]
  - [ ] Verify WORM storage prevents modification (operation fails)
  - [ ] Verify original PDF remains unchanged

- [ ] Performance verification
  - [ ] Verify JasperReports PDF generation completes within 3 seconds at p95 [Source: prd.md#NFR8]
  - [ ] Verify overall agreement generation (JasperReports + MinIO + DB update) completes within 5 seconds
  - [ ] Verify worker can handle 5 concurrent agreement generations without timeout
  - [ ] Verify correlation IDs propagated across all operations [Source: prd.md#NFR5]

- [ ] Configuration documentation
  - [ ] Add README section: "Agreement Generation Service" with JasperReports API configuration
  - [ ] Document MinIO configuration (endpoint, bucket, WORM policy)
  - [ ] Document template deployment process for JasperReports Server
  - [ ] Document template versioning strategy (version tracked in Vault product config)
  - [ ] Document SHA256 hash verification process for document integrity

## Change Log

| Date       | Version | Description                      | Author |
|------------|---------|----------------------------------|--------|
| 2025-10-17 | 0.1     | Initial draft created            | SM     |

## Dev Agent Record

*(This section will be populated by the development agent during implementation)*

### Agent Model Used

*(To be filled by dev agent)*

### Debug Log References

*(To be filled by dev agent)*

### Completion Notes

*(To be filled by dev agent)*

### File List

*(To be filled by dev agent)*

## QA Results

*(To be filled by QA agent)*
