# Story 1.8: Document Dual-Control Verification Workflow

## Status
Draft

## Story
**As a** Compliance Officer,  
**I want** to enforce dual-control verification where one officer uploads a document and a different officer must verify it,  
**so that** we prevent fraud and satisfy BoZ dual-control requirements.

## Acceptance Criteria
1. `UploadStatus` enum added to ClientDocument: Uploaded, PendingVerification, Verified, Rejected
2. DocumentLifecycleService.UploadDocumentAsync sets UploadStatus=Uploaded, stores UploadedBy from JWT claims
3. New API endpoint: PUT /api/clients/{id}/documents/{docId}/verify with VerifyDocumentRequest (Approved: bool, RejectionReason?: string)
4. DocumentLifecycleService.VerifyDocumentAsync validates:
   - Current user (from JWT) != UploadedBy (enforces dual-control)
   - Document exists and UploadStatus = Uploaded
   - If approved: Set UploadStatus=Verified, VerifiedBy=current user, VerifiedAt=NOW()
   - If rejected: Set UploadStatus=Rejected, RejectionReason from request
5. Database trigger created to prevent self-verification: `CHECK (VerifiedBy IS NULL OR VerifiedBy <> UploadedBy)`
6. Audit events logged for both upload and verification actions
7. Unit tests verify dual-control enforcement (self-verification throws exception)

## Tasks / Subtasks
- [ ] **Task 1: Add UploadStatus Enum** (AC: 1)
  - [ ] Create `UploadStatus.cs` enum in `Domain/Enums/`
  - [ ] Define values: Uploaded, PendingVerification, Verified, Rejected
  - [ ] Update ClientDocument entity to use UploadStatus enum instead of string
  - [ ] Add XML comments explaining each status
  - [ ] Update ClientDocumentConfiguration to map enum to string column

- [ ] **Task 2: Modify DocumentLifecycleService.UploadDocumentAsync** (AC: 2)
  - [ ] Extract userId from method parameter (passed from controller)
  - [ ] Set UploadStatus = UploadStatus.Uploaded when creating ClientDocument
  - [ ] Set UploadedBy = userId
  - [ ] Set UploadedAt = DateTime.UtcNow
  - [ ] Ensure VerifiedBy and VerifiedAt remain null
  - [ ] Log audit event: DocumentUploaded with EventData including uploadedBy

- [ ] **Task 3: Create VerifyDocumentRequest DTO**
  - [ ] Create `VerifyDocumentRequest.cs` in `Controllers/DTOs/`
  - [ ] Add properties:
    - `bool Approved` (true = verify, false = reject)
    - `string? RejectionReason` (required if Approved = false)
  - [ ] Create `VerifyDocumentRequestValidator.cs` with FluentValidation:
    - If Approved = false, RejectionReason is required
    - RejectionReason max length: 500 characters

- [ ] **Task 4: Implement VerifyDocumentAsync Method** (AC: 4)
  - [ ] Add method to IDocumentLifecycleService interface:
    - `Task<DocumentMetadataResponse> VerifyDocumentAsync(Guid clientId, Guid documentId, VerifyDocumentRequest request, string userId)`
  - [ ] Implement in DocumentLifecycleService:
    - Load ClientDocument from database
    - Verify document exists and belongs to client (404 if not found)
    - Validate UploadStatus = Uploaded (cannot verify already verified/rejected document)
    - **CRITICAL:** Validate userId != document.UploadedBy (dual-control enforcement)
    - If validation fails → Throw DualControlViolationException
    - If Approved = true:
      - Set UploadStatus = Verified
      - Set VerifiedBy = userId
      - Set VerifiedAt = DateTime.UtcNow
    - If Approved = false:
      - Set UploadStatus = Rejected
      - Set RejectionReason = request.RejectionReason
      - Set VerifiedBy = userId (who rejected)
      - Set VerifiedAt = DateTime.UtcNow
    - Save changes to database
    - Log audit event: DocumentVerified or DocumentRejected
    - Return updated document metadata

- [ ] **Task 5: Create API Endpoint for Document Verification** (AC: 3)
  - [ ] Add PUT /api/clients/{id}/documents/{docId}/verify to ClientDocumentController
  - [ ] Extract userId from JWT claims (User.FindFirst("sub").Value)
  - [ ] Call DocumentLifecycleService.VerifyDocumentAsync
  - [ ] Return 200 OK with updated document metadata
  - [ ] Handle exceptions:
    - DualControlViolationException → 403 Forbidden with clear error message
    - DocumentNotFoundException → 404 Not Found
    - InvalidOperationException (already verified) → 409 Conflict
  - [ ] Add `[Authorize]` attribute (require authentication)
  - [ ] Add XML comments for API documentation

- [ ] **Task 6: Create Database Constraint for Dual-Control** (AC: 5)
  - [ ] Create migration to add check constraint to ClientDocuments table
  - [ ] Add constraint: `CHECK (VerifiedBy IS NULL OR VerifiedBy <> UploadedBy)`
  - [ ] This ensures database-level enforcement even if application logic is bypassed
  - [ ] Document constraint behavior in migration comments
  - [ ] Test constraint: Attempt to insert record with VerifiedBy = UploadedBy → Should fail

- [ ] **Task 7: Create Custom Exception for Dual-Control Violations**
  - [ ] Create `DualControlViolationException.cs` in `Domain/Exceptions/`
  - [ ] Inherit from Exception
  - [ ] Add properties: UserId, UploadedBy, DocumentId
  - [ ] Override Message to provide clear error: "Dual-control violation: User {userId} cannot verify document they uploaded"

- [ ] **Task 8: Update Audit Logging** (AC: 6)
  - [ ] Modify DocumentLifecycleService.UploadDocumentAsync to log DocumentUploaded event
  - [ ] Include EventData: documentId, documentType, fileName, uploadedBy, fileSizeBytes
  - [ ] Add audit logging to VerifyDocumentAsync:
    - If approved → Log DocumentVerified event
    - If rejected → Log DocumentRejected event
  - [ ] Include EventData: documentId, verifiedBy, approved, rejectionReason (if applicable)
  - [ ] Ensure correlation ID included in all audit events

- [ ] **Task 9: Create Unit Tests** (AC: 7)
  - [ ] Create `DocumentDualControlTests.cs` test class
  - [ ] Test UploadDocumentAsync sets UploadStatus=Uploaded and UploadedBy=userId
  - [ ] Test VerifyDocumentAsync with different user → Success, status=Verified
  - [ ] Test VerifyDocumentAsync with same user → Throws DualControlViolationException
  - [ ] Test VerifyDocumentAsync approval → Sets Verified status, VerifiedBy, VerifiedAt
  - [ ] Test VerifyDocumentAsync rejection → Sets Rejected status, RejectionReason
  - [ ] Test verify already verified document → Throws InvalidOperationException
  - [ ] Test verify already rejected document → Throws InvalidOperationException
  - [ ] Test database constraint enforcement (using integration test with real DB)

- [ ] **Task 10: Create Integration Tests**
  - [ ] Test complete dual-control flow:
    - User A uploads document → UploadStatus=Uploaded
    - User B verifies document → UploadStatus=Verified
    - Verify ClientDocument record updated correctly
  - [ ] Test self-verification blocked:
    - User A uploads document
    - User A attempts to verify → 403 Forbidden
  - [ ] Test rejection flow:
    - User A uploads document
    - User B rejects with reason → UploadStatus=Rejected
  - [ ] Test audit trail:
    - Upload + Verify → Both events logged to AdminService
    - Verify WireMock received DocumentUploaded and DocumentVerified events
  - [ ] Test database constraint:
    - Attempt direct SQL update to set VerifiedBy = UploadedBy
    - Verify constraint violation error

## Dev Notes

### Previous Story Context
**From Story 1.6:**
- ClientDocument entity created with UploadStatus, UploadedBy, VerifiedBy fields
- DocumentLifecycleService.UploadDocumentAsync implemented
- Documents stored via KycDocumentService with metadata in SQL

**From Story 1.5:**
- AuditService available for logging upload and verification events

### Dual-Control Compliance Requirement
**Source:** [docs/domains/client-management/prd.md#dual-control-document-verification]

**BoZ Dual-Control Requirement:**
- Bank of Zambia regulations require dual-control for KYC document verification
- One officer uploads, a different officer must verify
- Prevents single point of fraud or manipulation
- Both uploader and verifier identity must be logged for audit

**Dual-Control Pattern:**
1. Officer A uploads document → Status: Uploaded, UploadedBy: A
2. Officer B reviews and verifies → Status: Verified, VerifiedBy: B
3. System enforces: VerifiedBy != UploadedBy
4. Both actions logged to AdminService with full audit trail

### UploadStatus State Machine
**Source:** [docs/domains/client-management/brownfield-architecture.md#clientdocument-entity]

**Valid Status Transitions:**
```
Uploaded → Verified (by different user)
Uploaded → Rejected (by different user)
Rejected → Uploaded (re-upload after rejection)
```

**Invalid Transitions:**
```
Verified → Rejected (cannot un-verify)
Rejected → Verified (must re-upload)
```

**Status Definitions:**
- **Uploaded:** Document uploaded, awaiting verification (initial state)
- **PendingVerification:** (Reserved for Camunda workflow integration in Story 1.11)
- **Verified:** Document verified by different officer, approved for KYC
- **Rejected:** Document rejected by verifier, reason captured

### Database Constraint Implementation
**Source:** [docs/domains/client-management/prd.md#dual-control-document-verification]

**SQL Check Constraint:**
```sql
ALTER TABLE ClientDocuments
ADD CONSTRAINT CK_ClientDocuments_DualControl
CHECK (VerifiedBy IS NULL OR VerifiedBy <> UploadedBy);
```

**Rationale:**
- Database-level enforcement provides defense-in-depth
- Prevents bypassing application logic (e.g., direct SQL updates)
- Constraint violation returns clear error message

**Testing Constraint:**
```sql
-- This should fail with constraint violation
INSERT INTO ClientDocuments (Id, ClientId, UploadedBy, VerifiedBy, ...)
VALUES (NEWID(), @clientId, 'user-123', 'user-123', ...);
-- Error: The INSERT statement conflicted with the CHECK constraint "CK_ClientDocuments_DualControl"
```

### Dual-Control Validation Logic
**CRITICAL Implementation:**

```csharp
public async Task<DocumentMetadataResponse> VerifyDocumentAsync(
    Guid clientId, 
    Guid documentId, 
    VerifyDocumentRequest request, 
    string userId)
{
    var document = await _context.ClientDocuments
        .FirstOrDefaultAsync(d => d.Id == documentId && d.ClientId == clientId);
    
    if (document == null)
        throw new DocumentNotFoundException(documentId);
    
    if (document.UploadStatus != UploadStatus.Uploaded)
        throw new InvalidOperationException($"Document cannot be verified in {document.UploadStatus} status");
    
    // CRITICAL: Dual-control enforcement
    if (document.UploadedBy == userId)
        throw new DualControlViolationException(userId, document.UploadedBy, documentId);
    
    if (request.Approved)
    {
        document.UploadStatus = UploadStatus.Verified;
        document.VerifiedBy = userId;
        document.VerifiedAt = DateTime.UtcNow;
    }
    else
    {
        document.UploadStatus = UploadStatus.Rejected;
        document.RejectionReason = request.RejectionReason;
        document.VerifiedBy = userId; // Who rejected
        document.VerifiedAt = DateTime.UtcNow;
    }
    
    await _context.SaveChangesAsync();
    
    // Audit logging
    await _auditService.LogAuditEventAsync(
        action: request.Approved ? "DocumentVerified" : "DocumentRejected",
        entityType: "ClientDocument",
        entityId: documentId.ToString(),
        actor: userId,
        eventData: new { 
            documentId, 
            verifiedBy = userId, 
            approved = request.Approved, 
            rejectionReason = request.RejectionReason 
        }
    );
    
    return MapToResponse(document);
}
```

### Error Response Format
**403 Forbidden (Dual-Control Violation):**
```json
{
  "error": "Dual-control violation",
  "message": "You cannot verify a document you uploaded. A different officer must perform verification.",
  "details": {
    "documentId": "guid",
    "uploadedBy": "user-guid",
    "attemptedBy": "user-guid"
  }
}
```

**409 Conflict (Invalid Status):**
```json
{
  "error": "Invalid operation",
  "message": "Document cannot be verified in Verified status. Only documents in Uploaded status can be verified.",
  "details": {
    "documentId": "guid",
    "currentStatus": "Verified"
  }
}
```

### Integration Verification Requirements
From PRD Story 1.8:
- **IV1: Database Constraint:** Trigger prevents self-verification even if service validation is bypassed
- **IV2: Audit Trail:** Both UploadedBy and VerifiedBy users logged to AdminService with distinct Action values
- **IV3: Existing Upload Flow:** Document upload without immediate verification still works (status remains Uploaded)

### Rejection Workflow
**When Document is Rejected:**
1. Verifier provides RejectionReason (e.g., "Photo unclear", "Document expired")
2. Document status set to Rejected
3. Client/Loan Officer notified of rejection (via Story 1.14 notifications)
4. Officer must re-upload corrected document
5. Re-uploaded document gets new ID, fresh Uploaded status
6. Original rejected document remains in history (audit trail)

### User Experience Considerations
**For Loan Officers (Uploaders):**
- Can see documents awaiting verification (Status=Uploaded)
- Cannot verify their own uploads (403 Forbidden if attempted)
- Receive notification when document verified or rejected

**For KYC Officers (Verifiers):**
- Can see list of documents pending verification
- Can filter to exclude documents they uploaded
- Must provide rejection reason if rejecting

### Performance Considerations
- Dual-control validation adds minimal overhead (single string comparison)
- Database constraint check is performant (indexed columns)
- No impact on upload performance

### Security Implications
- Dual-control prevents insider fraud (single officer cannot create fake documents)
- Audit trail provides accountability (who uploaded, who verified)
- Database constraint prevents bypassing via direct SQL manipulation

### Project Structure After This Story
```
apps/IntelliFin.ClientManagement/
├── Domain/
│   ├── Entities/
│   │   └── ClientDocument.cs                     # UPDATED - Use UploadStatus enum
│   ├── Enums/
│   │   └── UploadStatus.cs                       # NEW - Status enum
│   └── Exceptions/
│       └── DualControlViolationException.cs      # NEW - Custom exception
├── Infrastructure/
│   └── Persistence/
│       ├── Configurations/
│       │   └── ClientDocumentConfiguration.cs     # UPDATED - Map enum to string
│       └── Migrations/
│           └── YYYYMMDDHHMMSS_AddDualControlConstraint.cs  # NEW
├── Services/
│   ├── IDocumentLifecycleService.cs              # UPDATED - Add VerifyDocumentAsync
│   └── DocumentLifecycleService.cs               # UPDATED - Implement verification
├── Controllers/
│   ├── DTOs/
│   │   ├── VerifyDocumentRequest.cs              # NEW
│   │   └── VerifyDocumentRequestValidator.cs     # NEW
│   └── ClientDocumentController.cs               # UPDATED - Add verify endpoint
└── [existing files from Stories 1.1-1.7]
```

## Testing

### Testing Standards
**Source:** [docs/domains/client-management/prd.md#testing-integration-strategy]

- **Test Framework:** xUnit
- **Unit Tests:** Mock DbContext to test dual-control logic in isolation
- **Integration Tests:** TestContainers for SQL Server to test database constraint
- **Coverage Target:** 100% for dual-control validation logic (critical security feature)

### Specific Test Cases for This Story

**Unit Tests:**
1. **UploadDocumentAsync:**
   - Verify sets UploadStatus=Uploaded
   - Verify sets UploadedBy=userId from parameter
   - Verify VerifiedBy and VerifiedAt remain null

2. **VerifyDocumentAsync - Success:**
   - User A uploads document
   - User B verifies (different user)
   - Assert UploadStatus=Verified
   - Assert VerifiedBy=userB
   - Assert VerifiedAt set to current UTC time

3. **VerifyDocumentAsync - Dual-Control Violation:**
   - User A uploads document
   - User A attempts to verify
   - Assert throws DualControlViolationException
   - Assert exception message includes userId and uploadedBy

4. **VerifyDocumentAsync - Rejection:**
   - User A uploads document
   - User B rejects with reason "Document expired"
   - Assert UploadStatus=Rejected
   - Assert RejectionReason="Document expired"
   - Assert VerifiedBy=userB (who rejected)

5. **VerifyDocumentAsync - Invalid Status:**
   - Document already verified
   - Attempt to verify again
   - Assert throws InvalidOperationException

**Integration Tests:**
1. **Complete Dual-Control Flow:**
   - POST /api/clients/{id}/documents (as User A) → Upload document
   - Verify response: UploadStatus="Uploaded", uploadedBy="userA"
   - PUT /api/clients/{id}/documents/{docId}/verify (as User B) → Verify
   - Verify response: UploadStatus="Verified", verifiedBy="userB"
   - Query database: Verify ClientDocument record matches

2. **Self-Verification Blocked (API Level):**
   - Upload document as User A
   - Attempt to verify as User A
   - Assert 403 Forbidden response
   - Assert error message explains dual-control violation

3. **Database Constraint Enforcement:**
   - Upload document as User A (UploadedBy="userA")
   - Attempt direct SQL update: `UPDATE ClientDocuments SET VerifiedBy='userA' WHERE Id=...`
   - Assert SQL constraint violation error
   - Verify record NOT updated

4. **Audit Trail:**
   - Upload document → Verify DocumentUploaded event logged
   - Verify document → Verify DocumentVerified event logged
   - Assert both events have correct Actor values (uploader, verifier)
   - Assert EventData includes documentId, uploadedBy, verifiedBy

5. **Rejection Workflow:**
   - Upload document as User A
   - Reject as User B with reason "Photo unclear"
   - Assert UploadStatus="Rejected"
   - Assert RejectionReason="Photo unclear"
   - Assert DocumentRejected event logged

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
*This section will be populated by the development agent during implementation.*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*This section will be populated by the QA agent after implementation review.*
