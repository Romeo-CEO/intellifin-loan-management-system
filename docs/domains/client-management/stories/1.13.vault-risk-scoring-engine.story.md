# Story 1.13: Vault Integration and Risk Scoring Engine

## Status
Draft

## Story
**As a** Risk Manager,  
**I want** to compute customer risk scores using Vault-managed business rules that can be updated without code deployments,  
**so that** we can adapt risk assessment criteria as regulations and business conditions change.

## Acceptance Criteria
1. VaultSharp NuGet package added (version 1.15+)
2. `RiskProfile` entity created in `Domain/Entities` with fields: Id, ClientId (unique), RiskRating, RiskScore, ComputedAt, ComputedBy, RiskRulesVersion, RiskRulesChecksum, RuleExecutionLog, InputFactorsJson, IsCurrent
3. `VaultRiskConfigProvider` created in `Infrastructure/VaultClient/` implementing IRiskConfigProvider with:
   - GetCurrentConfigAsync() method
   - Polling mechanism (every 60 seconds)
   - Cache with version/checksum comparison
   - RegisterConfigChangeCallback() for hot-reload notifications
4. `RiskScoringService` created with ComputeRiskAsync method:
   - Retrieve current config from Vault
   - Build input factors JSON (kycComplete, amlRiskLevel, isPep, hasSanctionsHit)
   - Execute JSONLogic/CEL rules
   - Calculate risk score (0-100)
   - Map score to rating (Low: 0-25, Medium: 26-50, High: 51-100)
   - Store RiskProfile with rules version/checksum
5. `RiskAssessmentWorker` implementation for topic `client.kyc.risk-assessment`:
   - Call RiskScoringService.ComputeRiskAsync
   - Update Client.RiskRating and Client.RiskLastAssessedAt
   - Set workflow variable: riskRating
6. API endpoint: GET /api/clients/{id}/risk-profile
7. Integration tests with local Vault instance

## Tasks / Subtasks

- [ ] **Task 1: Add VaultSharp NuGet Package and Configuration** (AC: 1)
  - [ ] Add NuGet package `VaultSharp` version 1.15+
  - [ ] Update `IntelliFin.ClientManagement.csproj` with package reference
  - [ ] Create `VaultOptions.cs` configuration class in `Infrastructure/Configuration/`
  - [ ] Add Vault configuration section to `appsettings.json`:
    - `Address`: Vault server URL
    - `RoleName`: Service role for authentication
    - `ConfigPath`: Risk scoring rules path (`intellifin/client-management/risk-scoring-rules`)
    - `PollingIntervalSeconds`: Config refresh interval (default: 60)
    - `TimeoutSeconds`: Vault client timeout (default: 30)
  - [ ] Add development configuration in `appsettings.Development.json`
  - [ ] Verify package compatibility with .NET 9.0

- [ ] **Task 2: Create RiskProfile Entity and Configuration** (AC: 2)
  - [ ] Create `RiskProfile.cs` entity in `Domain/Entities/`
  - [ ] Add properties:
    - `Guid Id` (Primary key)
    - `Guid ClientId` (Foreign key, unique per current profile)
    - `string RiskRating` (Low, Medium, High)
    - `int RiskScore` (0-100 numeric score)
    - `DateTime ComputedAt`
    - `string ComputedBy` (Worker name or user ID)
    - `string RiskRulesVersion` (Vault config version/tag)
    - `string RiskRulesChecksum` (SHA256 of rules JSON)
    - `string? RuleExecutionLog` (JSON: which rules fired, scores)
    - `string InputFactorsJson` (JSON: input data used for scoring)
    - `bool IsCurrent` (Latest risk assessment flag)
    - `DateTime? SupersededAt` (When replaced by newer assessment)
  - [ ] Add navigation property to `Client.RiskProfile`
  - [ ] Create `RiskProfileConfiguration.cs` EF Core configuration:
    - Configure table mapping and indexes
    - Unique index on `(ClientId, IsCurrent)` where `IsCurrent = true`
    - Index on `ComputedAt` for historical queries
    - Check constraint for `RiskScore BETWEEN 0 AND 100`
  - [ ] Create EF Core migration for RiskProfile table
  - [ ] Update `ClientManagementDbContext` with `DbSet<RiskProfile>`

- [ ] **Task 3: Create Vault Client Configuration and Service** (AC: 3)
  - [ ] Create `VaultClientConfiguration.cs` in `Infrastructure/Configuration/`
  - [ ] Implement Vault authentication and client setup:
    - Support JWT authentication with service role
    - Support Token authentication for development
    - Configure timeout and retry policies
  - [ ] Create `IRiskConfigProvider.cs` interface in `Services/`:
    - `Task<RiskScoringConfig> GetCurrentConfigAsync()`
    - `void RegisterConfigChangeCallback(Action<RiskScoringConfig> callback)`
    - `Task<bool> ValidateConfigAsync(RiskScoringConfig config)`
  - [ ] Create `VaultRiskConfigProvider.cs` implementation:
    - Implement Vault KV v2 client for config retrieval
    - Cache current config in memory with version tracking
    - Polling mechanism with configurable interval
    - Version/checksum comparison for change detection
    - Thread-safe config updates with callbacks
  - [ ] Register Vault services in DI container as singletons
  - [ ] Add error handling for Vault connectivity issues

- [ ] **Task 4: Create Risk Scoring Configuration Models** 
  - [ ] Create `RiskScoringConfig.cs` model in `Domain/Models/`:
    - `string Version` (Semantic version of rules)
    - `string Checksum` (SHA256 hash of rules content)
    - `DateTime LastModified`
    - `Dictionary<string, RiskRule> Rules` (Named rules collection)
    - `Dictionary<string, RiskThreshold> Thresholds` (Rating mappings)
    - `RiskScoringOptions Options` (Global scoring options)
  - [ ] Create `RiskRule.cs` model:
    - `string Name` (Rule identifier)
    - `string Description` (Human-readable description)
    - `int Points` (Score contribution)
    - `string Condition` (JSONLogic or CEL expression)
    - `bool IsEnabled` (Allow disabling rules)
    - `int Priority` (Execution order)
  - [ ] Create `RiskThreshold.cs` model:
    - `string Rating` (Low, Medium, High)
    - `int MinScore` (Minimum score for rating)
    - `int MaxScore` (Maximum score for rating)
    - `string Description` (Rating description)
  - [ ] Create `InputFactors.cs` model for standardized inputs:
    - `bool KycComplete`, `string AmlRiskLevel`, `bool IsPep`
    - `bool HasSanctionsHit`, `int DocumentCount`, `bool IsHighValue`
  - [ ] Add JSON serialization attributes for Vault storage

- [ ] **Task 5: Implement Risk Scoring Service** (AC: 4)
  - [ ] Create `IRiskScoringService.cs` interface in `Services/`:
    - `Task<RiskProfile> ComputeRiskAsync(Guid clientId, string computedBy)`
    - `Task<RiskProfile> RecomputeRiskAsync(Guid clientId, string reason)`
    - `Task<InputFactors> BuildInputFactorsAsync(Guid clientId)`
    - `Task<List<RiskProfile>> GetRiskHistoryAsync(Guid clientId)`
  - [ ] Create `VaultRiskScoringService.cs` implementation:
    - Inject `IRiskConfigProvider` and database context
    - Implement `ComputeRiskAsync` method with full workflow
    - Build input factors from client, KYC status, AML screenings
    - Execute rules engine with current Vault configuration
    - Calculate total score and map to rating
    - Create audit trail in `RuleExecutionLog`
  - [ ] Implement rules execution engine:
    - Support JSONLogic expressions for complex conditions
    - Evaluate each enabled rule against input factors
    - Aggregate scores with priority ordering
    - Handle rule execution errors gracefully
  - [ ] Add comprehensive logging and error handling
  - [ ] Create unit tests with mock config and various client scenarios

- [ ] **Task 6: Create JSONLogic Rules Engine Integration**
  - [ ] Add NuGet package `JsonLogic.Net` for rule evaluation
  - [ ] Create `RulesExecutionEngine.cs` class:
    - `Task<RulesExecutionResult> EvaluateRulesAsync(RiskScoringConfig config, InputFactors factors)`
    - Support for complex JSONLogic expressions
    - Rule priority and dependency handling
    - Detailed execution logging for audit
  - [ ] Implement rule evaluation logic:
    - Convert `InputFactors` to JSONLogic data format
    - Execute each rule's condition against input data
    - Calculate score contributions for matching rules
    - Generate execution log with rule names, conditions, results
  - [ ] Add rule validation:
    - Syntax validation for JSONLogic expressions
    - Input factor validation against expected schema
    - Rule circular dependency detection
  - [ ] Create unit tests for various rule combinations and edge cases

- [ ] **Task 7: Update RiskAssessmentWorker with Vault Integration** (AC: 5)
  - [ ] Update `RiskAssessmentWorker.cs` (created in Story 1.11):
    - Replace hardcoded risk calculation with `IRiskScoringService`
    - Extract client ID from workflow variables
    - Call `RiskScoringService.ComputeRiskAsync`
    - Update `Client.RiskRating` and `Client.RiskLastAssessedAt`
    - Set workflow variables: `riskScore`, `riskRating`, `riskRulesVersion`
  - [ ] Add error handling for Vault connectivity issues:
    - Fallback to basic scoring if Vault unavailable
    - Log configuration issues and alert operations
    - Retry mechanism with exponential backoff
  - [ ] Update worker registration and testing:
    - Ensure proper DI of risk scoring service
    - Mock Vault integration for unit tests
    - Test with actual Vault instance for integration tests
  - [ ] Add performance monitoring for risk calculation time

- [ ] **Task 8: Create Risk Profile API Endpoints** (AC: 6)
  - [ ] Create `RiskProfileController.cs` in `Controllers/`
  - [ ] Implement `GET /api/clients/{id}/risk-profile` endpoint:
    - Retrieve current risk profile for client
    - Include risk score, rating, computation date, rules version
    - Return 404 if client has no risk assessment
    - Add caching headers for performance
  - [ ] Implement additional risk-related endpoints:
    - `GET /api/clients/{id}/risk-history` - Historical risk assessments
    - `POST /api/clients/{id}/risk/recompute` - Manual risk recalculation
    - `GET /api/clients/{id}/risk/factors` - Input factors used in scoring
  - [ ] Create response DTOs:
    - `RiskProfileResponse` with formatted risk data
    - `RiskHistoryResponse` with trend analysis
    - `InputFactorsResponse` with current factor values
  - [ ] Add authentication and authorization
  - [ ] Create API documentation and examples

- [ ] **Task 9: Implement Hot-Reload Configuration Management**
  - [ ] Create `VaultConfigurationMonitor.cs` as BackgroundService:
    - Poll Vault every 60 seconds (configurable)
    - Compare version/checksum with cached config
    - Detect configuration changes and trigger reload
    - Notify registered callbacks of config changes
  - [ ] Implement configuration change handling:
    - Validate new configuration before applying
    - Update cached configuration atomically
    - Log configuration changes with version details
    - Trigger risk recalculation for affected clients (optional)
  - [ ] Add configuration rollback mechanism:
    - Store previous configuration version
    - Rollback capability if new config causes errors
    - Admin API endpoint for manual rollback
  - [ ] Create health check for Vault connectivity:
    - Verify connection to Vault server
    - Check config path accessibility
    - Monitor configuration age and staleness
  - [ ] Add integration tests for hot-reload functionality

- [ ] **Task 10: Create Sample Vault Configuration and Seeding**
  - [ ] Create sample risk scoring configuration JSON:
    - Realistic rules for Zambian banking context
    - KYC completeness, AML risk, PEP status rules
    - Document verification and client profile factors
    - Graduated risk thresholds with clear boundaries
  - [ ] Design rule examples:
    - **Basic Rules:** KYC incomplete (+20 points), AML high risk (+50 points)
    - **PEP Rules:** Active PEP (+30 points), Former PEP (+15 points)
    - **Document Rules:** Missing documents (+10 points each)
    - **Profile Rules:** High-value customer (+5 points), suspicious activity (+25 points)
  - [ ] Create Vault seeding script or documentation:
    - Initialize Vault secrets engine
    - Create service authentication role
    - Upload initial risk scoring configuration
    - Set up access policies
  - [ ] Document configuration management procedures:
    - How to update risk rules safely
    - Testing new configurations in staging
    - Rollback procedures for problematic configs
  - [ ] Create development seed data for local testing

- [ ] **Task 11: Create Risk Scoring Analytics and Reporting**
  - [ ] Create `RiskAnalyticsService.cs` for risk trend analysis:
    - `Task<RiskDistributionReport> GetRiskDistributionAsync()`
    - `Task<RiskTrendReport> GetRiskTrendsAsync(int days)`
    - `Task<RuleEffectivenessReport> GetRuleEffectivenessAsync()`
  - [ ] Implement analytics calculations:
    - Risk rating distribution (% Low, Medium, High)
    - Risk score trends over time
    - Rule firing frequency and effectiveness
    - Configuration version usage statistics
  - [ ] Create reporting DTOs and API endpoints:
    - `GET /api/risk/analytics/distribution` - Current risk distribution
    - `GET /api/risk/analytics/trends` - Risk trends over time
    - `GET /api/risk/analytics/rules` - Rule effectiveness metrics
  - [ ] Add caching and performance optimization:
    - Cache analytical calculations for performance
    - Background job for pre-calculating reports
    - Pagination for large datasets
  - [ ] Create unit tests for analytics calculations

- [ ] **Task 12: Implement Risk Recalculation and Batch Processing**
  - [ ] Create `RiskRecalculationService.cs` for bulk operations:
    - `Task RecalculateAllClientsAsync(string reason)` 
    - `Task RecalculateByRiskRatingAsync(string rating, string reason)`
    - `Task RecalculateByDateRangeAsync(DateTime from, DateTime to)`
  - [ ] Implement batch processing logic:
    - Process clients in configurable batch sizes (default: 100)
    - Rate limiting to avoid overwhelming database
    - Progress tracking and cancellation support
    - Comprehensive logging of batch operations
  - [ ] Create admin API endpoints:
    - `POST /api/risk/recalculate/all` - Recalculate all clients
    - `POST /api/risk/recalculate/rating/{rating}` - Recalculate by rating
    - `GET /api/risk/recalculation/status` - Check batch operation status
  - [ ] Add background job scheduling:
    - Scheduled recalculation jobs (e.g., weekly)
    - Trigger recalculation on configuration changes
    - Queue-based processing for large operations
  - [ ] Create integration tests for batch operations

- [ ] **Task 13: Create Comprehensive Integration Tests** (AC: 7)
  - [ ] Create `VaultRiskScoringIntegrationTests.cs` test class
  - [ ] Set up test infrastructure:
    - TestContainers for Vault server (if available) or mock Vault
    - Test database with sample clients and risk data
    - Mock or embedded configuration for reliable testing
  - [ ] Test complete risk scoring workflow:
    - Vault configuration retrieval and caching
    - Risk calculation with various client profiles
    - Hot-reload configuration changes
    - Risk profile storage and retrieval
  - [ ] Test error handling scenarios:
    - Vault connectivity failures
    - Invalid configuration formats
    - Rules execution errors
    - Database transaction failures
  - [ ] Test performance and concurrency:
    - Multiple concurrent risk calculations
    - Configuration changes during active calculations
    - Large batch recalculation operations
  - [ ] Verify integration with KYC workflow:
    - Risk assessment worker calls new scoring service
    - Workflow variables updated correctly
    - EDD escalation based on Vault-computed risk

- [ ] **Task 14: Update Service Registration and Configuration**
  - [ ] Update `Extensions/ServiceCollectionExtensions.cs` to register:
    - `IVaultClient` and Vault configuration services
    - `IRiskConfigProvider` and `VaultRiskConfigProvider`
    - `IRiskScoringService` and `VaultRiskScoringService`
    - `VaultConfigurationMonitor` background service
    - Rules execution engine and analytics services
  - [ ] Update `Program.cs` configuration:
    - Register Vault client with authentication
    - Add risk scoring health checks
    - Configure hot-reload monitoring
  - [ ] Add configuration validation:
    - Validate Vault connection settings at startup
    - Verify risk scoring configuration path exists
    - Check service authentication and permissions
  - [ ] Update existing services integration:
    - Update RiskAssessmentWorker registration
    - Ensure proper service lifecycle management

- [ ] **Task 15: Create Risk Scoring Monitoring and Alerts**
  - [ ] Add metrics collection for risk scoring:
    - Risk calculations performed per hour
    - Configuration reload events and timing
    - Rule execution time and success rates
    - Error rates and failure types
  - [ ] Create alerts for critical issues:
    - Vault connectivity failures
    - Configuration parsing errors
    - Unusual risk score distributions
    - Performance degradation in risk calculation
  - [ ] Add structured logging for compliance:
    - All risk calculations with correlation IDs
    - Configuration changes with approval tracking
    - Rule execution details for audit
    - Batch operation progress and results
  - [ ] Create dashboards for risk management:
    - Real-time risk distribution charts
    - Configuration version tracking
    - Rule effectiveness metrics
    - System health and performance indicators
  - [ ] Document monitoring and alerting procedures

## Dev Notes

### Vault Integration Architecture
**Source:** [docs/domains/client-management/brownfield-architecture.md#vault-integration-for-risk-profiling]

**Configuration Pattern:**
- **Engine:** KV v2 secrets engine
- **Path:** `intellifin/client-management/risk-scoring-rules`
- **Authentication:** JWT service account with read-only policy
- **Hot-Reload:** 60-second polling with version/checksum comparison
- **Caching:** In-memory cache with atomic updates

**Vault Setup Commands:**
```bash
# Enable KV v2 engine
vault secrets enable -path=intellifin kv-v2

# Write initial risk scoring config
vault kv put intellifin/client-management/risk-scoring-rules \
  version=1.0.0 \
  checksum=abc123 \
  rules='{"kyc_incomplete": {"points": 20, "condition": "kycComplete == false"}}'

# Create policy for service
vault policy write client-management-risk-ro - <<EOF
path "intellifin/data/client-management/risk-scoring-rules" {
  capabilities = ["read"]
}
EOF

# Create service role and token
vault auth enable jwt
vault write auth/jwt/role/client-management-risk \
  bound_audiences="intellifin" \
  bound_subject="client-management-service" \
  user_claim="sub" \
  policies="client-management-risk-ro"
```

### Risk Scoring Configuration Schema
**Sample Vault Configuration:**
```json
{
  "version": "1.2.0",
  "checksum": "sha256:abc123...",
  "lastModified": "2025-10-17T07:00:00Z",
  "options": {
    "maxScore": 100,
    "defaultRating": "Medium",
    "enableAuditLogging": true
  },
  "rules": {
    "kyc_incomplete": {
      "name": "KYC Incomplete",
      "description": "Client has incomplete KYC documentation",
      "points": 20,
      "condition": "kycComplete == false",
      "isEnabled": true,
      "priority": 1
    },
    "aml_high_risk": {
      "name": "AML High Risk",
      "description": "AML screening returned high risk",
      "points": 50,
      "condition": "amlRiskLevel == 'High'",
      "isEnabled": true,
      "priority": 2
    },
    "pep_active": {
      "name": "Active PEP",
      "description": "Client is an active Politically Exposed Person",
      "points": 30,
      "condition": "isPep == true",
      "isEnabled": true,
      "priority": 3
    },
    "sanctions_hit": {
      "name": "Sanctions Hit",
      "description": "Client matches sanctions list",
      "points": 75,
      "condition": "hasSanctionsHit == true",
      "isEnabled": true,
      "priority": 0
    },
    "high_value_customer": {
      "name": "High Value Customer",
      "description": "Customer with high transaction volumes",
      "points": 10,
      "condition": "isHighValue == true",
      "isEnabled": true,
      "priority": 5
    }
  },
  "thresholds": {
    "low": {
      "rating": "Low",
      "minScore": 0,
      "maxScore": 25,
      "description": "Low risk - standard monitoring"
    },
    "medium": {
      "rating": "Medium", 
      "minScore": 26,
      "maxScore": 50,
      "description": "Medium risk - enhanced monitoring"
    },
    "high": {
      "rating": "High",
      "minScore": 51,
      "maxScore": 100,
      "description": "High risk - requires EDD"
    }
  }
}
```

### Risk Scoring Service Implementation
**Core Algorithm:**
```csharp
public async Task<RiskProfile> ComputeRiskAsync(Guid clientId, string computedBy)
{
    var config = await _riskConfigProvider.GetCurrentConfigAsync();
    var inputFactors = await BuildInputFactorsAsync(clientId);
    
    var executionResult = await _rulesEngine.EvaluateRulesAsync(config, inputFactors);
    
    var totalScore = Math.Min(executionResult.TotalScore, config.Options.MaxScore);
    var rating = DetermineRating(totalScore, config.Thresholds);
    
    // Supersede current risk profile
    await SupersedeCurrentRiskProfileAsync(clientId);
    
    var riskProfile = new RiskProfile
    {
        Id = Guid.NewGuid(),
        ClientId = clientId,
        RiskRating = rating,
        RiskScore = totalScore,
        ComputedAt = DateTime.UtcNow,
        ComputedBy = computedBy,
        RiskRulesVersion = config.Version,
        RiskRulesChecksum = config.Checksum,
        RuleExecutionLog = JsonSerializer.Serialize(executionResult.ExecutionLog),
        InputFactorsJson = JsonSerializer.Serialize(inputFactors),
        IsCurrent = true
    };
    
    await _context.RiskProfiles.AddAsync(riskProfile);
    await _context.SaveChangesAsync();
    
    return riskProfile;
}
```

### JSONLogic Rules Integration
**Rules Engine Implementation:**
```csharp
public async Task<RulesExecutionResult> EvaluateRulesAsync(
    RiskScoringConfig config, 
    InputFactors factors)
{
    var executionLog = new List<RuleExecution>();
    var totalScore = 0;
    
    var inputData = JsonSerializer.Serialize(factors);
    var jsonLogicData = JsonSerializer.Deserialize<object>(inputData);
    
    foreach (var rule in config.Rules.Values.Where(r => r.IsEnabled).OrderBy(r => r.Priority))
    {
        try
        {
            var conditionResult = JsonLogic.Apply(rule.Condition, jsonLogicData);
            var conditionMet = Convert.ToBoolean(conditionResult);
            
            var execution = new RuleExecution
            {
                RuleName = rule.Name,
                Condition = rule.Condition,
                ConditionMet = conditionMet,
                PointsAwarded = conditionMet ? rule.Points : 0,
                ExecutedAt = DateTime.UtcNow
            };
            
            executionLog.Add(execution);
            
            if (conditionMet)
            {
                totalScore += rule.Points;
                _logger.LogInformation("Rule {RuleName} fired, awarded {Points} points", 
                    rule.Name, rule.Points);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error executing rule {RuleName}: {Condition}", 
                rule.Name, rule.Condition);
            
            executionLog.Add(new RuleExecution
            {
                RuleName = rule.Name,
                Condition = rule.Condition,
                ConditionMet = false,
                PointsAwarded = 0,
                Error = ex.Message,
                ExecutedAt = DateTime.UtcNow
            });
        }
    }
    
    return new RulesExecutionResult
    {
        TotalScore = totalScore,
        ExecutionLog = executionLog,
        RulesEvaluated = config.Rules.Count,
        ExecutionTime = executionLog.Last().ExecutedAt - executionLog.First().ExecutedAt
    };
}
```

### Hot-Reload Configuration Management
**Configuration Monitor Service:**
```csharp
public class VaultConfigurationMonitor : BackgroundService
{
    private readonly IRiskConfigProvider _configProvider;
    private readonly ILogger<VaultConfigurationMonitor> _logger;
    private readonly VaultOptions _options;
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await _configProvider.CheckForConfigChangesAsync();
                await Task.Delay(TimeSpan.FromSeconds(_options.PollingIntervalSeconds), stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking Vault configuration");
                await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken); // Backoff on error
            }
        }
    }
}
```

**Configuration Change Detection:**
```csharp
public async Task CheckForConfigChangesAsync()
{
    try
    {
        var vaultConfig = await _vaultClient.V1.Secrets.KeyValue.V2
            .ReadSecretAsync("risk-scoring-rules", mountPoint: "intellifin/client-management");
            
        var newVersion = vaultConfig.Data.Data["version"].ToString();
        var newChecksum = vaultConfig.Data.Data["checksum"].ToString();
        
        if (newVersion != _cachedConfig.Version || newChecksum != _cachedConfig.Checksum)
        {
            _logger.LogInformation("Configuration change detected: {OldVersion} -> {NewVersion}", 
                _cachedConfig.Version, newVersion);
                
            var newConfig = ParseConfiguration(vaultConfig.Data.Data);
            
            if (await ValidateConfigAsync(newConfig))
            {
                var oldConfig = _cachedConfig;
                _cachedConfig = newConfig;
                
                // Notify all registered callbacks
                foreach (var callback in _callbacks)
                {
                    try
                    {
                        callback(newConfig);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error in configuration change callback");
                    }
                }
                
                _logger.LogInformation("Configuration updated successfully to version {Version}", newVersion);
            }
        }
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to check for configuration changes");
        throw;
    }
}
```

### Database Schema
**RiskProfile Table:**
```sql
CREATE TABLE RiskProfiles (
    Id uniqueidentifier PRIMARY KEY DEFAULT NEWSEQUENTIALID(),
    ClientId uniqueidentifier NOT NULL,
    RiskRating varchar(20) NOT NULL CHECK (RiskRating IN ('Low', 'Medium', 'High')),
    RiskScore int NOT NULL CHECK (RiskScore BETWEEN 0 AND 100),
    ComputedAt datetime2(7) NOT NULL DEFAULT GETUTCDATE(),
    ComputedBy varchar(256) NOT NULL,
    RiskRulesVersion varchar(50) NOT NULL,
    RiskRulesChecksum varchar(128) NOT NULL,
    RuleExecutionLog nvarchar(max), -- JSON
    InputFactorsJson nvarchar(max) NOT NULL, -- JSON
    IsCurrent bit NOT NULL DEFAULT 1,
    SupersededAt datetime2(7),
    
    CONSTRAINT FK_RiskProfiles_ClientId FOREIGN KEY (ClientId) REFERENCES Clients(Id) ON DELETE CASCADE
);

CREATE UNIQUE INDEX IX_RiskProfiles_ClientId_IsCurrent 
ON RiskProfiles(ClientId, IsCurrent) 
WHERE IsCurrent = 1;

CREATE INDEX IX_RiskProfiles_ComputedAt ON RiskProfiles(ComputedAt);
CREATE INDEX IX_RiskProfiles_RiskRating ON RiskProfiles(RiskRating);
CREATE INDEX IX_RiskProfiles_RiskScore ON RiskProfiles(RiskScore);
```

### Integration with Previous Stories
**KYC Workflow Integration (Story 1.11):**
- `RiskAssessmentWorker` updated to use Vault-based scoring
- Workflow variables include risk rules version for audit
- EDD escalation based on Vault-configured thresholds

**AML Integration (Story 1.12):**
- Input factors include AML screening results
- Sanctions hits and PEP matches influence risk calculation
- EDD workflow triggered by Vault-configured risk thresholds

**Client Management (Stories 1.3-1.4):**
- Client entity updated with current risk profile navigation
- Risk assessment integrated into client lifecycle
- Historical risk profiles maintained for audit compliance

### Performance Considerations
**Caching Strategy:**
- In-memory config cache with atomic updates
- Risk profile caching for frequently accessed clients
- Background cache warming for critical configurations

**Optimization Techniques:**
- Batch risk recalculation for efficiency
- Asynchronous configuration updates
- Connection pooling for Vault client
- Database query optimization with proper indexes

### Security Considerations
**Vault Access Control:**
- Service-specific authentication roles
- Read-only access to configuration paths
- Token rotation and renewal handling
- Network security for Vault communication

**Configuration Security:**
- Configuration validation before application
- Audit logging of all configuration changes
- Rollback capability for problematic configs
- Separation of duties for config approval

### Project Structure After This Story
```
apps/IntelliFin.ClientManagement/
├── Domain/
│   ├── Entities/
│   │   └── RiskProfile.cs                          # NEW - Risk profile entity
│   └── Models/
│       ├── RiskScoringConfig.cs                    # NEW - Vault config model
│       ├── RiskRule.cs                             # NEW - Rule definition
│       ├── InputFactors.cs                         # NEW - Scoring inputs
│       └── RulesExecutionResult.cs                 # NEW - Execution results
├── Services/
│   ├── IRiskScoringService.cs                      # NEW - Risk scoring interface
│   ├── VaultRiskScoringService.cs                  # NEW - Vault-based implementation
│   ├── IRiskConfigProvider.cs                      # NEW - Config provider interface
│   ├── VaultRiskConfigProvider.cs                  # NEW - Vault config provider
│   ├── RulesExecutionEngine.cs                     # NEW - JSONLogic engine
│   ├── RiskAnalyticsService.cs                     # NEW - Analytics service
│   └── RiskRecalculationService.cs                 # NEW - Batch operations
├── Controllers/
│   └── RiskProfileController.cs                    # NEW - Risk API endpoints
├── Infrastructure/
│   ├── Configuration/
│   │   ├── VaultOptions.cs                         # NEW - Vault configuration
│   │   └── VaultClientConfiguration.cs             # NEW - Vault client setup
│   ├── VaultClient/
│   │   └── VaultConfigurationMonitor.cs            # NEW - Hot-reload monitor
│   └── Persistence/
│       ├── Configurations/
│       │   └── RiskProfileConfiguration.cs         # NEW - EF configuration
│       └── Migrations/
│           └── {timestamp}_AddRiskProfile.cs       # NEW - Migration
├── Workflows/
│   └── CamundaWorkers/
│       └── RiskAssessmentWorker.cs                 # UPDATED - Use Vault scoring
└── [existing files from Stories 1.1-1.12]
```

## Testing

### Testing Standards
**Source:** [docs/domains/client-management/prd.md#testing-integration-strategy]

- **Test Framework:** xUnit with TestContainers for Vault integration
- **Coverage Target:** 90% for risk scoring service (business critical)
- **Integration Tests:** TestContainers or Docker-based Vault for realistic testing
- **Performance Tests:** Risk calculation under load, configuration hot-reload

### Specific Test Cases for This Story

**Unit Tests - Risk Scoring Service:**
1. **Risk Calculation:**
   - Various client profiles with different risk factors
   - Rule combinations and score aggregation
   - Rating threshold boundary conditions
   - Input factor edge cases (null values, extreme ranges)

2. **Rules Engine:**
   - JSONLogic expression evaluation accuracy
   - Complex conditional logic (AND, OR, nested conditions)
   - Rule priority and execution order
   - Error handling for malformed expressions

3. **Configuration Management:**
   - Configuration parsing and validation
   - Version and checksum comparison
   - Cache invalidation and updates
   - Callback registration and notification

**Integration Tests - Vault Integration:**
1. **Configuration Retrieval:**
   - Successful config retrieval from Vault
   - Authentication and authorization
   - Network failure handling and retries
   - Configuration format validation

2. **Hot-Reload Testing:**
   - Configuration change detection
   - Cache update without service restart
   - Callback notification system
   - Rollback on invalid configuration

3. **End-to-End Risk Scoring:**
   - Complete workflow from client data to risk profile
   - Database persistence and retrieval
   - Integration with KYC workflow workers
   - Performance under concurrent load

**Performance Tests:**
1. **Risk Calculation Performance:**
   - Single risk calculation < 500ms
   - Batch calculation of 1000 clients < 60 seconds
   - Memory usage remains stable during batch operations
   - Concurrent calculations without resource contention

2. **Configuration Performance:**
   - Configuration retrieval < 2 seconds
   - Cache hit ratio > 95% during normal operation
   - Hot-reload detection within 60 seconds
   - No performance degradation during config updates

### Test File Structure
```
tests/IntelliFin.ClientManagement.Tests/
├── Services/
│   ├── VaultRiskScoringServiceTests.cs
│   ├── RulesExecutionEngineTests.cs
│   ├── VaultRiskConfigProviderTests.cs
│   ├── RiskAnalyticsServiceTests.cs
│   └── RiskRecalculationServiceTests.cs
├── Infrastructure/
│   └── VaultClient/
│       └── VaultConfigurationMonitorTests.cs
└── Controllers/
    └── RiskProfileControllerTests.cs

tests/IntelliFin.ClientManagement.IntegrationTests/
├── Services/
│   ├── VaultRiskScoringIntegrationTests.cs
│   └── RiskScoringPerformanceTests.cs
└── Infrastructure/
    └── VaultIntegrationTests.cs
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-17 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
*This section will be populated by the development agent during implementation.*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*This section will be populated by the QA agent after implementation review.*