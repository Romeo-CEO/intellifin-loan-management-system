# Story 1.7: CommunicationsService Integration for Event-Based Notifications

## Status
Draft

## Story
**As a** Customer,  
**I want** to receive SMS and email notifications when my KYC status changes,  
**so that** I stay informed about my loan application progress.

## Acceptance Criteria
1. `CommunicationsClient.cs` Refit interface created in `Integration/` with POST /api/communications/send method
2. `SendNotificationRequest` DTO created matching CommunicationsService schema (TemplateId, RecipientId, Channel, PersonalizationData)
3. `CommunicationConsent` entity created in `Domain/Entities` with fields: Id, ClientId, ConsentType, SmsEnabled, EmailEnabled, InAppEnabled, CallEnabled, ConsentGivenAt, ConsentGivenBy, ConsentRevokedAt
4. `ConsentManagementService` created with methods: GetConsentAsync, UpdateConsentAsync, CheckConsentAsync
5. API endpoints created:
   - GET /api/clients/{id}/consents (get consent preferences)
   - PUT /api/clients/{id}/consents (update consent preferences)
6. Notification helper method created: SendConsentBasedNotificationAsync checks consent before calling CommunicationsClient
7. Integration tests with WireMock verify notifications sent only when consent granted

## Tasks / Subtasks
- [ ] **Task 1: Create CommunicationsService Client Interface** (AC: 1)
  - [ ] Add `ICommunicationsClient.cs` in `Integration/`
  - [ ] Define Refit method `Task<SendNotificationResponse> SendNotificationAsync([Body] SendNotificationRequest request)`
  - [ ] Add Refit attribute: `[Post("/api/communications/send")]`
  - [ ] Configure Refit client in DI with CommunicationsService base URL from appsettings.json
  - [ ] Add timeout configuration (30 seconds)
  - [ ] Configure retry policy with Polly (3 retries, exponential backoff)

- [ ] **Task 2: Create DTOs for CommunicationsService** (AC: 2)
  - [ ] Create `SendNotificationRequest.cs` in `Integration/DTOs/`
  - [ ] Add properties:
    - `string TemplateId` (e.g., "kyc_approved", "document_expiring")
    - `string RecipientId` (Client ID)
    - `string Channel` (SMS, Email, InApp, Push)
    - `Dictionary<string, string> PersonalizationData` (template variables)
    - `string? ScheduledFor` (optional scheduled send time)
  - [ ] Create `SendNotificationResponse.cs` (notificationId, status, sentAt)
  - [ ] Ensure DTOs match existing CommunicationsService contract

- [ ] **Task 3: Create CommunicationConsent Entity** (AC: 3)
  - [ ] Create `CommunicationConsent.cs` in `Domain/Entities/`
  - [ ] Add properties:
    - Id, ClientId
    - ConsentType (enum: Marketing, Operational, Regulatory)
    - SmsEnabled, EmailEnabled, InAppEnabled, CallEnabled (channel flags)
    - ConsentGivenAt, ConsentGivenBy (who granted consent)
    - ConsentRevokedAt, RevocationReason
    - CorrelationId (audit tracking)
  - [ ] Add navigation property to Client entity
  - [ ] Add XML comments for all properties

- [ ] **Task 4: Create EF Core Configuration for CommunicationConsent**
  - [ ] Create `CommunicationConsentConfiguration.cs` in `Infrastructure/Persistence/Configurations/`
  - [ ] Configure table name `CommunicationConsents` (plural)
  - [ ] Configure foreign key to Clients table with CASCADE DELETE
  - [ ] Configure index on `(ClientId, ConsentType)` for fast lookup
  - [ ] Configure required vs optional fields
  - [ ] Register configuration in DbContext

- [ ] **Task 5: Generate and Apply Migration**
  - [ ] Run `dotnet ef migrations add AddCommunicationConsent`
  - [ ] Review generated migration
  - [ ] Apply migration to local development database
  - [ ] Verify CommunicationConsents table created

- [ ] **Task 6: Create ConsentManagementService** (AC: 4)
  - [ ] Create `IConsentManagementService.cs` interface in `Services/`
  - [ ] Create `ConsentManagementService.cs` implementation
  - [ ] Implement `GetConsentAsync(Guid clientId, string consentType)`:
    - Query CommunicationConsent for client and type
    - Return consent record or null if not found
  - [ ] Implement `UpdateConsentAsync(Guid clientId, UpdateConsentRequest request, string userId)`:
    - Load or create consent record
    - Update channel flags (SmsEnabled, EmailEnabled, etc.)
    - Set ConsentGivenAt/ConsentGivenBy if new consent
    - Set ConsentRevokedAt if revoking consent
    - Save to database
    - Log audit event: ConsentUpdated
  - [ ] Implement `CheckConsentAsync(Guid clientId, string consentType, string channel)`:
    - Query consent for client and type
    - Return true if consent exists and channel enabled
    - Return false if consent revoked or channel disabled
  - [ ] Implement `GetAllConsentsAsync(Guid clientId)`:
    - Return all consent records for client
  - [ ] Register service in DI container

- [ ] **Task 7: Create API Endpoints for Consent Management** (AC: 5)
  - [ ] Create `ClientConsentController.cs` in `Controllers/`
  - [ ] Add GET /api/clients/{id}/consents endpoint:
    - Call ConsentManagementService.GetAllConsentsAsync
    - Return 200 OK with list of ConsentResponse DTOs
  - [ ] Add PUT /api/clients/{id}/consents endpoint:
    - Accept UpdateConsentRequest (consentType, sms, email, inApp, call)
    - Extract userId from JWT claims
    - Call ConsentManagementService.UpdateConsentAsync
    - Return 200 OK with updated consent
  - [ ] Add `[Authorize]` attribute to all endpoints
  - [ ] Add XML comments for API documentation

- [ ] **Task 8: Create NotificationService with Consent Checking** (AC: 6)
  - [ ] Create `INotificationService.cs` interface in `Services/`
  - [ ] Create `NotificationService.cs` implementation
  - [ ] Implement `SendConsentBasedNotificationAsync(Guid clientId, string templateId, string consentType, string channel, Dictionary<string, string> personalizationData)`:
    - Call ConsentManagementService.CheckConsentAsync
    - If consent not granted → Log warning, return without sending
    - If consent granted → Build SendNotificationRequest
    - Call CommunicationsClient.SendNotificationAsync
    - Log audit event: NotificationSent
    - Handle CommunicationsService errors gracefully
  - [ ] Implement `SendNotificationAsync(SendNotificationRequest request)`:
    - Direct send without consent check (for regulatory notifications)
    - Call CommunicationsClient.SendNotificationAsync
  - [ ] Register service in DI container

- [ ] **Task 9: Create DTOs for Consent API**
  - [ ] Create `ConsentResponse.cs` (id, clientId, consentType, channels, givenAt, revokedAt)
  - [ ] Create `UpdateConsentRequest.cs` (consentType, smsEnabled, emailEnabled, inAppEnabled, callEnabled)
  - [ ] Create `UpdateConsentRequestValidator.cs` with FluentValidation rules:
    - ConsentType: Required, must be one of: Marketing, Operational, Regulatory
    - At least one channel must be enabled if granting consent

- [ ] **Task 10: Integrate with Audit Service**
  - [ ] Call AuditService after consent updated (Action: ConsentUpdated)
  - [ ] Include EventData: consentType, channels, givenBy
  - [ ] Call AuditService after notification sent (Action: NotificationSent)
  - [ ] Include EventData: templateId, channel, recipientId

- [ ] **Task 11: Create Integration Tests with WireMock** (AC: 7)
  - [ ] Create `CommunicationsServiceIntegrationTests.cs`
  - [ ] Start WireMock server for CommunicationsService
  - [ ] Stub POST /api/communications/send endpoint
  - [ ] Test consent granted + notification sent → Verify CommunicationsService called
  - [ ] Test consent revoked + notification attempt → Verify CommunicationsService NOT called
  - [ ] Test consent not found → Verify notification not sent (default deny)
  - [ ] Test channel disabled → Verify notification not sent for that channel
  - [ ] Test update consent → Verify CommunicationConsent record updated
  - [ ] Test audit logging → Verify ConsentUpdated and NotificationSent events logged
  - [ ] Test CommunicationsService unavailable → Verify retry with exponential backoff

## Dev Notes

### Previous Story Context
**From Story 1.3:**
- Client entity has navigation property for Consents collection

**From Story 1.5:**
- AuditService available for logging consent and notification events

### CommunicationsService Overview
**Source:** [docs/domains/client-management/brownfield-architecture.md#related-services]

**CommunicationsService Purpose:**
- Multi-channel notification service (SMS, Email, In-App, Push)
- Handles template management and personalization
- Supports scheduled notifications
- Provides delivery status tracking

**Integration Pattern:**
- Client Management requests notifications via HTTP API
- CommunicationsService handles actual delivery to carriers (Twilio, SendGrid, etc.)
- Asynchronous delivery with webhook callbacks for status updates (future)

### CommunicationConsent Entity Specification
**Source:** [docs/domains/client-management/brownfield-architecture.md#communicationconsent-entity]

Full CommunicationConsent entity structure:

```csharp
public class CommunicationConsent
{
    public Guid Id { get; set; }
    public Guid ClientId { get; set; }              // FK to Client
    
    public string ConsentType { get; set; }         // Marketing, Operational, Regulatory
    public bool SmsEnabled { get; set; }
    public bool EmailEnabled { get; set; }
    public bool InAppEnabled { get; set; }
    public bool CallEnabled { get; set; }
    
    // Consent lifecycle
    public DateTime ConsentGivenAt { get; set; }
    public string ConsentGivenBy { get; set; }      // ClientSelf, Officer, System
    public DateTime? ConsentRevokedAt { get; set; }
    public string? RevocationReason { get; set; }
    
    // Audit
    public string? CorrelationId { get; set; }
    
    // Navigation
    public Client Client { get; set; }
}
```

**ConsentType Enum:**
- **Marketing:** Promotional messages, product offers, newsletters
- **Operational:** KYC status updates, loan application status, payment reminders
- **Regulatory:** Compliance notifications, legal notices (cannot be disabled)

**Channel Flags:**
- `SmsEnabled`: SMS/Text messages
- `EmailEnabled`: Email notifications
- `InAppEnabled`: In-app notifications (mobile/web app)
- `CallEnabled`: Phone call notifications

### CommunicationsService API Contract
**Expected Existing API (from CommunicationsService):**

```
POST /api/communications/send
Content-Type: application/json
Body: SendNotificationRequest
{
  "templateId": "kyc_approved",
  "recipientId": "client-guid",
  "channel": "SMS",
  "personalizationData": {
    "clientName": "John Doe",
    "kycStatus": "Approved",
    "approvalDate": "2025-10-16"
  },
  "scheduledFor": null  // Optional: ISO 8601 timestamp for scheduled send
}

Response: SendNotificationResponse
{
  "notificationId": "guid",
  "status": "Queued",  // Queued, Sent, Failed
  "sentAt": "2025-10-16T22:00:00Z",
  "channel": "SMS"
}
```

### Consent-Based Notification Flow
**Source:** [docs/domains/client-management/prd.md#consent-based-notifications]

**Flow for Operational Notifications (e.g., KYC Approved):**
1. Event occurs (e.g., KYC approved)
2. NotificationService.SendConsentBasedNotificationAsync called
3. Check ConsentManagementService.CheckConsentAsync("Operational", "SMS")
4. If consent granted:
   - Build SendNotificationRequest with templateId "kyc_approved"
   - Add personalizationData (clientName, kycStatus, etc.)
   - Call CommunicationsClient.SendNotificationAsync
   - Log audit event: NotificationSent
5. If consent not granted:
   - Log warning: "Notification skipped due to lack of consent"
   - Do NOT call CommunicationsService

**Flow for Regulatory Notifications:**
- Regulatory notifications bypass consent check (legally required)
- Use NotificationService.SendNotificationAsync directly
- ConsentType="Regulatory" cannot be disabled by customer

### Consent Management Rules
**Source:** [docs/domains/client-management/prd.md#communication-consent-management]

**Default Consent Behavior:**
- New clients have NO consent by default (opt-in model)
- Regulatory consent is always granted (system-generated)
- Operational consent must be explicitly granted during onboarding
- Marketing consent is separate and optional

**Consent Lifecycle:**
- **Granted:** ConsentGivenAt set, ConsentRevokedAt is null, channel flags enabled
- **Revoked:** ConsentRevokedAt set, RevocationReason captured
- **Restored:** Create new consent record (preserve history)

**Audit Requirements:**
- Every consent change logged to AdminService
- Consent history maintained for regulatory compliance
- Who granted consent (ClientSelf, Officer, System) tracked

### Notification Template Examples
**Expected Templates in CommunicationsService:**

| Template ID | Purpose | ConsentType | Channels | Personalization Data |
|-------------|---------|-------------|----------|---------------------|
| `kyc_approved` | KYC approval notification | Operational | SMS, Email | clientName, approvalDate |
| `kyc_rejected` | KYC rejection notification | Operational | SMS, Email | clientName, rejectionReason |
| `kyc_edd_required` | EDD escalation notice | Operational | SMS, Email | clientName, eddReason |
| `document_expiring_soon` | Document expiry warning | Operational | SMS, Email | clientName, documentType, expiryDate, daysRemaining |
| `loan_approved` | Loan approval | Operational | SMS, Email, InApp | clientName, loanAmount, approvalDate |
| `payment_reminder` | Payment due reminder | Operational | SMS, Email | clientName, amountDue, dueDate |
| `regulatory_notice` | Regulatory notification | Regulatory | SMS, Email | clientName, noticeType, details |

### Integration Verification Requirements
From PRD Story 1.7:
- **IV1: CommunicationsService Contract:** Notification requests conform to existing SendNotificationRequest schema
- **IV2: Consent Enforcement:** Notifications are NOT sent if customer has SmsEnabled=false or EmailEnabled=false
- **IV3: Template Compatibility:** TemplateId values reference existing templates in CommunicationsService

### Error Handling
- **404 Not Found:** Client not found, template not found
- **400 Bad Request:** Invalid channel, missing personalization data required by template
- **429 Too Many Requests:** Rate limit exceeded (CommunicationsService)
- **500 Internal Server Error:** CommunicationsService unavailable
- **503 Service Unavailable:** SMS gateway down, email service down

**Retry Policy:**
- Max retries: 3
- Delays: 1s, 2s, 4s (exponential backoff)
- Retry on: 5xx errors, network failures
- No retry on: 4xx errors (indicates bad request)

### Configuration in appsettings.json
```json
{
  "CommunicationsService": {
    "BaseUrl": "https://communications.intellifin.local",
    "Timeout": "00:00:30"
  },
  "Consent": {
    "DefaultOperationalConsent": false,
    "DefaultMarketingConsent": false,
    "RegulatoryConsentAlwaysEnabled": true
  }
}
```

### Personalization Data Best Practices
- Use consistent naming: `clientName`, not `customer_name` or `CustomerName`
- All dates in ISO 8601 format: `2025-10-16T22:00:00Z`
- Currency amounts as formatted strings: `"ZMW 5,000.00"`
- Boolean values as strings: `"Yes"`, `"No"` (not `true`/`false`)

### Security and Privacy
- **PII Protection:** Personalization data may contain PII, ensure encrypted in transit (TLS)
- **Consent Audit:** All consent changes logged for GDPR/POPIA compliance
- **Right to Revoke:** Customers can revoke consent at any time
- **Data Retention:** Notification logs retained for 7 years (BoZ requirement)

### Project Structure After This Story
```
apps/IntelliFin.ClientManagement/
├── Domain/
│   └── Entities/
│       ├── Client.cs                              # From Story 1.3
│       └── CommunicationConsent.cs                 # NEW - Consent entity
├── Infrastructure/
│   └── Persistence/
│       ├── Configurations/
│       │   └── CommunicationConsentConfiguration.cs  # NEW - EF Core config
│       ├── Migrations/
│       │   └── YYYYMMDDHHMMSS_AddCommunicationConsent.cs  # NEW
│       └── ClientManagementDbContext.cs            # UPDATED - Add DbSet<CommunicationConsent>
├── Integration/
│   ├── DTOs/
│   │   ├── SendNotificationRequest.cs              # NEW
│   │   └── SendNotificationResponse.cs             # NEW
│   └── ICommunicationsClient.cs                    # NEW - Refit interface
├── Services/
│   ├── IConsentManagementService.cs                # NEW
│   ├── ConsentManagementService.cs                 # NEW
│   ├── INotificationService.cs                     # NEW
│   └── NotificationService.cs                      # NEW
├── Controllers/
│   ├── DTOs/
│   │   ├── ConsentResponse.cs                      # NEW
│   │   ├── UpdateConsentRequest.cs                 # NEW
│   │   └── UpdateConsentRequestValidator.cs        # NEW
│   └── ClientConsentController.cs                  # NEW - Consent API
└── [existing files from Stories 1.1-1.6]
```

## Testing

### Testing Standards
**Source:** [docs/domains/client-management/prd.md#testing-integration-strategy]

- **Test Framework:** xUnit
- **Mocking:** WireMock for CommunicationsService, Moq for services
- **Integration Tests:** TestContainers for SQL Server
- **Coverage Target:** 90% for ConsentManagementService and NotificationService

### Specific Test Cases for This Story

**Unit Tests:**
1. CheckConsentAsync - Consent granted → Returns true
2. CheckConsentAsync - Consent revoked → Returns false
3. CheckConsentAsync - Consent not found → Returns false (default deny)
4. CheckConsentAsync - Channel disabled → Returns false
5. UpdateConsentAsync - New consent → Creates record with ConsentGivenAt
6. UpdateConsentAsync - Revoke consent → Sets ConsentRevokedAt
7. SendConsentBasedNotificationAsync - Consent granted → Calls CommunicationsService
8. SendConsentBasedNotificationAsync - No consent → Does NOT call CommunicationsService

**Integration Tests with WireMock:**
1. **Consent Grant Flow:**
   - Create client
   - Grant Operational consent via PUT /api/clients/{id}/consents
   - Verify CommunicationConsent record created
   - Verify audit event logged

2. **Consent Revoke Flow:**
   - Create client with consent
   - Revoke consent via PUT /api/clients/{id}/consents
   - Verify ConsentRevokedAt set
   - Verify audit event logged

3. **Notification with Consent:**
   - Grant SMS consent
   - Send notification via NotificationService
   - Verify WireMock received POST /api/communications/send
   - Verify audit event logged

4. **Notification without Consent:**
   - Do NOT grant consent
   - Attempt to send notification
   - Verify WireMock did NOT receive request
   - Verify warning logged

5. **Channel-Specific Consent:**
   - Grant SMS consent but NOT email
   - Send SMS notification → Success
   - Send email notification → Blocked

6. **Regulatory Notification Bypass:**
   - Do NOT grant any consent
   - Send regulatory notification
   - Verify notification sent regardless of consent

7. **CommunicationsService Retry:**
   - Stub CommunicationsService to return 503
   - Send notification
   - Verify 3 retry attempts with exponential backoff

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
*This section will be populated by the development agent during implementation.*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*This section will be populated by the QA agent after implementation review.*
