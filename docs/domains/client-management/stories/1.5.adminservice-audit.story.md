# Story 1.5: AdminService Audit Trail Integration

## Status
Draft

## Story
**As a** Compliance Officer,  
**I want** every client profile change, document action, and compliance event to be logged immutably in AdminService,  
**so that** we have a complete audit trail for BoZ regulatory inspections.

## Acceptance Criteria
1. `AdminServiceClient.cs` Refit interface created in `Integration/` with POST /api/audit/events and POST /api/audit/events/batch methods
2. `AuditEventDto` class created matching AdminService schema (Actor, Action, EntityType, EntityId, CorrelationId, IpAddress, EventData)
3. `AuditMiddleware` created to capture correlation ID and IP address for all requests
4. ClientService methods modified to call AdminServiceClient.LogAuditEventAsync after:
   - Client created (Action: ClientCreated)
   - Client updated (Action: ClientUpdated, EventData includes version number)
5. Audit event batching configured: buffer 100 events or 5 seconds, whichever first
6. Retry policy configured with exponential backoff (3 retries, 1s/2s/4s delays)
7. Dead letter queue configured for audit events that fail after max retries
8. Integration tests with WireMock verify audit events sent correctly

## Tasks / Subtasks
- [ ] **Task 1: Create AdminService Client Interface** (AC: 1)
  - [ ] Create directory `Integration/` in project root
  - [ ] Add NuGet package `Refit` version 7.0+
  - [ ] Create `IAdminServiceClient.cs` Refit interface
  - [ ] Define method `Task<AuditEventResponse> LogAuditEventAsync([Body] AuditEventDto auditEvent)`
  - [ ] Define method `Task<BatchAuditResponse> LogAuditEventsBatchAsync([Body] List<AuditEventDto> auditEvents)`
  - [ ] Add Refit attributes: `[Post("/api/audit/events")]`, `[Post("/api/audit/events/batch")]`
  - [ ] Configure Refit client in DI with AdminService base URL from appsettings.json
  - [ ] Add timeout configuration (30 seconds)

- [ ] **Task 2: Create AuditEventDto Matching AdminService Schema** (AC: 2)
  - [ ] Create `AuditEventDto.cs` in `Integration/DTOs/`
  - [ ] Add properties matching AdminService contract:
    - `string Actor` (User ID who performed action)
    - `string Action` (e.g., "ClientCreated", "ClientUpdated")
    - `string EntityType` (e.g., "Client", "ClientDocument")
    - `string EntityId` (GUID of affected entity)
    - `string CorrelationId` (Request correlation ID)
    - `string? IpAddress` (Client IP address)
    - `string? EventData` (JSON with additional context)
    - `DateTime Timestamp` (UTC timestamp)
    - `string? PreviousEventHash` (For chain integrity, if enabled)
  - [ ] Add JSON serialization attributes for camelCase naming
  - [ ] Create `AuditEventResponse` DTO for API response
  - [ ] Create `BatchAuditResponse` DTO for batch response

- [ ] **Task 3: Create Audit Middleware** (AC: 3)
  - [ ] Create `AuditMiddleware.cs` in `Middleware/` (if not already in Story 1.2)
  - [ ] Capture `X-Correlation-ID` from request headers (from Story 1.2)
  - [ ] Capture client IP address from `HttpContext.Connection.RemoteIpAddress`
  - [ ] Store correlation ID and IP address in `HttpContext.Items` for access by services
  - [ ] Register middleware in `Program.cs` early in pipeline

- [ ] **Task 4: Create AuditService Abstraction** 
  - [ ] Create `IAuditService.cs` interface in `Services/`
  - [ ] Define method `Task LogAuditEventAsync(string action, string entityType, string entityId, string actor, object? eventData = null)`
  - [ ] Create `AuditService.cs` implementation
  - [ ] Inject IAdminServiceClient and IHttpContextAccessor
  - [ ] Implement LogAuditEventAsync:
    - Build AuditEventDto from parameters
    - Retrieve CorrelationId and IpAddress from HttpContext
    - Set Timestamp = DateTime.UtcNow
    - Serialize eventData to JSON if provided
    - Add to batch queue (see Task 5)
  - [ ] Register service in DI container

- [ ] **Task 5: Implement Audit Event Batching** (AC: 5)
  - [ ] Create `AuditBatchingService.cs` as BackgroundService
  - [ ] Create in-memory queue (ConcurrentQueue<AuditEventDto>)
  - [ ] Configure batching parameters in appsettings.json:
    - `BatchSize: 100`
    - `BatchIntervalSeconds: 5`
  - [ ] Implement batch processing logic:
    - Every 5 seconds OR when queue reaches 100 events
    - Dequeue all pending events
    - Call AdminServiceClient.LogAuditEventsBatchAsync
    - Log batch success/failure
  - [ ] Ensure in-flight batches are flushed on application shutdown
  - [ ] Register as hosted service

- [ ] **Task 6: Configure Retry Policy with Polly** (AC: 6)
  - [ ] Add NuGet package `Polly` version 8.0+
  - [ ] Add NuGet package `Polly.Extensions.Http` version 3.0+
  - [ ] Configure Refit client with Polly retry policy:
    - Retry on HTTP 5xx errors
    - Retry on network failures (HttpRequestException)
    - Max 3 retries
    - Exponential backoff: 1s, 2s, 4s
  - [ ] Log retry attempts with correlation ID
  - [ ] Add circuit breaker: Open after 5 consecutive failures, half-open after 30 seconds

- [ ] **Task 7: Configure Dead Letter Queue** (AC: 7)
  - [ ] Create `AuditEventDeadLetterQueue.cs` 
  - [ ] Use file-based DLQ (write failed events to `logs/audit-dlq.json`)
  - [ ] Alternative: Use database table `AuditEventDLQ` for persistence
  - [ ] Log failed events to DLQ after max retries exceeded
  - [ ] Include failure reason, retry count, last attempt timestamp
  - [ ] Create monitoring alert for DLQ growth (optional)
  - [ ] Document DLQ replay procedure in README

- [ ] **Task 8: Modify ClientService to Log Audit Events** (AC: 4)
  - [ ] Inject IAuditService into ClientService
  - [ ] In CreateClientAsync, after successful save:
    - Call AuditService.LogAuditEventAsync("ClientCreated", "Client", clientId, userId)
    - Include EventData: { "nrc": "...", "firstName": "...", "lastName": "..." }
  - [ ] In UpdateClientAsync, after successful save:
    - Call AuditService.LogAuditEventAsync("ClientUpdated", "Client", clientId, userId)
    - Include EventData: { "versionNumber": X, "changedFields": [...] }
  - [ ] Ensure audit logging does NOT block the request (fire-and-forget or async without await)

- [ ] **Task 9: Create Integration Tests with WireMock** (AC: 8)
  - [ ] Add NuGet package `WireMock.Net` version 1.5+
  - [ ] Create `AdminServiceAuditTests.cs` test class
  - [ ] Start WireMock server in test setup
  - [ ] Stub AdminService endpoints: POST /api/audit/events, POST /api/audit/events/batch
  - [ ] Test client create → Verify audit event sent with Action="ClientCreated"
  - [ ] Test client update → Verify audit event sent with Action="ClientUpdated" and version number
  - [ ] Test batch processing → Create 150 events, verify 2 batches sent (100 + 50)
  - [ ] Test retry on failure → Stub 500 error, verify 3 retry attempts with exponential backoff
  - [ ] Test dead letter queue → Stub permanent failure, verify event written to DLQ
  - [ ] Verify CorrelationId and IpAddress included in all audit events

## Dev Notes

### Previous Story Context
**From Story 1.3:**
- ClientService implements CreateClientAsync and UpdateClientAsync
- Client entity has audit fields: CreatedBy, CreatedAt, UpdatedBy, UpdatedAt

**From Story 1.4:**
- ClientVersioningService creates version snapshots on updates
- ChangeSummaryJson contains list of changed fields

**From Story 1.2:**
- Correlation ID middleware captures X-Correlation-ID header
- Global exception handler ensures errors are logged

### AdminService Integration Requirements
**Source:** [docs/domains/client-management/brownfield-architecture.md#related-services]

**AdminService Purpose:**
- Centralized audit logging and compliance reporting for all IntelliFin services
- Provides immutable audit trail with optional blockchain-style chain integrity
- Stores audit events in tamper-evident format for regulatory compliance

**AdminService API Endpoints (Existing):**
```
POST /api/audit/events
Body: AuditEventDto
Response: AuditEventResponse { id, timestamp, hash }

POST /api/audit/events/batch
Body: List<AuditEventDto>
Response: BatchAuditResponse { processedCount, failedCount, failedIds }
```

### AuditEventDto Schema
**Source:** [docs/domains/client-management/prd.md#adminservice-audit-event-schema]

AdminService expects audit events in the following format:

```csharp
public class AuditEventDto
{
    public string Actor { get; set; }                // User ID (from JWT sub claim)
    public string Action { get; set; }               // Action name (ClientCreated, ClientUpdated, etc.)
    public string EntityType { get; set; }           // Entity type (Client, ClientDocument, etc.)
    public string EntityId { get; set; }             // GUID of affected entity
    public string CorrelationId { get; set; }        // Request correlation ID
    public string? IpAddress { get; set; }           // Client IP address
    public string? EventData { get; set; }           // JSON with additional context
    public DateTime Timestamp { get; set; }          // UTC timestamp
    public string? PreviousEventHash { get; set; }   // For chain integrity (optional)
}
```

**Action Naming Convention:**
- PascalCase with entity name prefix: `ClientCreated`, `ClientUpdated`, `ClientDeleted`
- Document actions: `DocumentUploaded`, `DocumentVerified`, `DocumentRejected`
- Compliance actions: `KycApproved`, `KycRejected`, `EddEscalated`, `RiskProfileComputed`

**EventData JSON Examples:**

Client Created:
```json
{
  "nrc": "123456/78/9",
  "firstName": "John",
  "lastName": "Doe",
  "branchId": "guid"
}
```

Client Updated:
```json
{
  "versionNumber": 2,
  "changedFields": ["PrimaryPhone", "PhysicalAddress"],
  "changeReason": "Customer request"
}
```

### Audit Batching Strategy
**Source:** [docs/domains/client-management/prd.md#audit-event-throughput]

**Batching Parameters:**
- Buffer size: 100 events
- Time interval: 5 seconds
- Behavior: Send batch when EITHER condition met (whichever first)

**Rationale:**
- Reduces HTTP overhead for high-volume operations
- Ensures events sent within 5 seconds (acceptable audit delay)
- AdminService optimized for batch processing

**Implementation Pattern:**
```csharp
public class AuditBatchingService : BackgroundService
{
    private readonly ConcurrentQueue<AuditEventDto> _queue = new();
    private readonly Timer _timer;
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
            await ProcessBatchAsync();
        }
    }
    
    private async Task ProcessBatchAsync()
    {
        if (_queue.Count == 0) return;
        
        var batch = new List<AuditEventDto>();
        while (batch.Count < 100 && _queue.TryDequeue(out var evt))
        {
            batch.Add(evt);
        }
        
        await _adminServiceClient.LogAuditEventsBatchAsync(batch);
    }
}
```

### Retry Policy Configuration
**Source:** [docs/domains/client-management/prd.md#risk-assessment-and-mitigation]

**Retry Strategy:**
- Max retries: 3
- Delays: 1s, 2s, 4s (exponential backoff)
- Retry on: HTTP 5xx, network failures (HttpRequestException)
- No retry on: HTTP 4xx (client errors—indicates schema mismatch)

**Circuit Breaker:**
- Open after 5 consecutive failures
- Half-open after 30 seconds
- Prevents cascading failures if AdminService is down

**Polly Configuration:**
```csharp
services.AddRefitClient<IAdminServiceClient>()
    .ConfigureHttpClient(c => c.BaseAddress = new Uri(adminServiceUrl))
    .AddPolicyHandler(Policy
        .Handle<HttpRequestException>()
        .OrResult<HttpResponseMessage>(r => (int)r.StatusCode >= 500)
        .WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1))))
    .AddPolicyHandler(Policy
        .Handle<HttpRequestException>()
        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)));
```

### Dead Letter Queue (DLQ) Design
**Purpose:** Capture audit events that fail after max retries to prevent data loss

**Implementation Options:**
1. **File-based DLQ** (simpler): Write failed events to `logs/audit-dlq.json`
2. **Database DLQ** (more robust): Store in `AuditEventDLQ` table

**DLQ Record Structure:**
```json
{
  "auditEvent": { /* original AuditEventDto */ },
  "failureReason": "AdminService returned 503 after 3 retries",
  "retryCount": 3,
  "lastAttemptAt": "2025-10-16T22:00:00Z",
  "addedToDlqAt": "2025-10-16T22:00:15Z"
}
```

**DLQ Replay Procedure:**
1. Fix root cause (e.g., AdminService restored)
2. Read events from DLQ
3. Re-submit to AdminService via batch endpoint
4. Remove from DLQ on success

### Chain Integrity (Optional)
**Source:** [docs/domains/client-management/prd.md#adminservice-audit-event-schema]

AdminService supports optional blockchain-style chain integrity:
- Each audit event includes `PreviousEventHash` field
- Hash is SHA256 of previous event's JSON
- Creates tamper-evident audit chain

**Note:** Client Management does NOT compute PreviousEventHash—AdminService handles this internally.

### Integration Verification Requirements
From PRD Story 1.5:
- **IV1: AdminService Contract:** Audit events conform to existing AuditEventDto schema without breaking AdminService
- **IV2: Chain Integrity:** Audit events include PreviousEventHash field if AdminService chain integrity is enabled (AdminService responsibility)
- **IV3: Resilience:** Service continues functioning if AdminService is temporarily unavailable (events queued for retry)

### Performance and Reliability
- **Async Fire-and-Forget:** Audit logging should NOT block business logic
- **Event Loss Tolerance:** < 1% acceptable (per NFR5 in PRD)
- **AdminService Unavailability:** Client Management continues operating, events queued
- **DLQ Monitoring:** Alert operations if DLQ grows beyond 1000 events

### Configuration in appsettings.json
```json
{
  "AdminService": {
    "BaseUrl": "https://admin.intellifin.local",
    "Timeout": "00:00:30"
  },
  "AuditBatching": {
    "BatchSize": 100,
    "BatchIntervalSeconds": 5,
    "EnableDeadLetterQueue": true,
    "DeadLetterQueuePath": "logs/audit-dlq.json"
  }
}
```

### Project Structure After This Story
```
apps/IntelliFin.ClientManagement/
├── Integration/
│   ├── DTOs/
│   │   ├── AuditEventDto.cs                        # NEW
│   │   ├── AuditEventResponse.cs                   # NEW
│   │   └── BatchAuditResponse.cs                   # NEW
│   ├── IAdminServiceClient.cs                      # NEW - Refit interface
│   └── AuditEventDeadLetterQueue.cs                # NEW - DLQ implementation
├── Services/
│   ├── IAuditService.cs                            # NEW
│   ├── AuditService.cs                             # NEW
│   ├── AuditBatchingService.cs                     # NEW - Background service
│   └── ClientService.cs                            # UPDATED - Add audit logging
├── Middleware/
│   └── AuditMiddleware.cs                          # NEW or UPDATED
└── [existing files from Stories 1.1-1.4]
```

## Testing

### Testing Standards
**Source:** [docs/domains/client-management/prd.md#testing-integration-strategy]

- **Test Framework:** xUnit
- **Mocking:** WireMock for AdminService HTTP endpoints
- **Integration Tests:** Verify audit events sent with correct schema

### Specific Test Cases for This Story

**Integration Tests with WireMock:**
1. **Client Create Audit:**
   - Create client via API
   - Verify WireMock received POST /api/audit/events with Action="ClientCreated"
   - Verify AuditEventDto contains correct Actor, EntityId, CorrelationId

2. **Client Update Audit:**
   - Update client via API
   - Verify audit event sent with Action="ClientUpdated"
   - Verify EventData includes versionNumber and changedFields

3. **Batch Processing:**
   - Trigger 150 audit events rapidly
   - Verify 2 batch requests sent (100 + 50 events)
   - Verify batch interval (5 seconds max delay)

4. **Retry on Failure:**
   - Stub AdminService to return 503 Service Unavailable
   - Trigger audit event
   - Verify 3 retry attempts with exponential backoff (1s, 2s, 4s)

5. **Dead Letter Queue:**
   - Stub AdminService to always fail
   - Trigger audit event
   - Verify event written to DLQ after max retries

6. **Circuit Breaker:**
   - Stub AdminService to fail 5 consecutive times
   - Verify circuit opens (no more requests sent)
   - Wait 30 seconds, verify circuit half-opens and retries

7. **Correlation ID Propagation:**
   - Send request with X-Correlation-ID header
   - Verify audit event includes same correlation ID

8. **IP Address Capture:**
   - Send request from specific IP
   - Verify audit event includes correct IP address

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
*This section will be populated by the development agent during implementation.*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*This section will be populated by the QA agent after implementation review.*
