# Story 1.9: Vault-Based Rule Engine with Dynamic Rule Evaluation

## Status
Draft

## Story
**As a** Backend Developer  
**I want** to replace hard-coded risk rules with a Vault-driven rule evaluation engine  
**so that** business can configure risk policies dynamically for different products

## Acceptance Criteria

1. Create `VaultRuleEngine` service that evaluates rules from Vault configuration
2. Implement rule evaluation context builder combining client data, bureau data, affordability data
3. Support comparison operators: `<=`, `>=`, `<`, `>`, `==` in rule conditions
4. Evaluate mathematical expressions in rule conditions (e.g., `requestedAmount / monthlyIncome`)
5. Calculate pass/fail score for each rule based on evaluation result
6. Apply rule weight to calculate weighted score contribution
7. Sum all weighted scores to produce composite risk score
8. Determine risk grade from composite score using grade thresholds from Vault
9. Determine decision (Approved/Conditional/ManualReview/Rejected) using decision matrix from Vault
10. Generate detailed rule evaluation results showing each rule's input, output, and contribution

## Tasks / Subtasks

- [ ] Create VaultRuleEngine service (AC: 1)
  - [ ] Create `Services/Core/VaultRuleEngine.cs`
  - [ ] Inject `IVaultConfigService` for rule configuration
  - [ ] Implement `EvaluateRulesAsync` method
  - [ ] Select rules based on product type (PAYROLL | BUSINESS)
  - [ ] Filter only active rules

- [ ] Build evaluation context (AC: 2)
  - [ ] Create `RuleEvaluationContext` class
  - [ ] Include client data (income, employment, etc.)
  - [ ] Include bureau data (credit score, debt, accounts)
  - [ ] Include affordability data (DTI, disposable income)
  - [ ] Include request data (amount, term, product type)
  - [ ] Flatten nested data for expression evaluation

- [ ] Implement expression evaluator (AC: 3, 4)
  - [ ] Add NuGet package: `NCalc` or similar expression parser
  - [ ] Create `ExpressionEvaluator` class
  - [ ] Support mathematical operations (+, -, *, /)
  - [ ] Support comparison operators (<=, >=, <, >, ==)
  - [ ] Replace variables in expression with context values
  - [ ] Evaluate expression and return boolean result

- [ ] Implement rule evaluation logic (AC: 5, 6)
  - [ ] For each rule, build condition expression
  - [ ] Evaluate condition against context
  - [ ] Determine pass/fail based on evaluation result
  - [ ] Apply pass score if rule passes, fail score if fails
  - [ ] Multiply score by rule weight to get weighted score
  - [ ] Store evaluation result with details

- [ ] Calculate composite score (AC: 7)
  - [ ] Sum all weighted scores from rule evaluations
  - [ ] Store individual rule contributions
  - [ ] Return composite score with breakdown
  - [ ] Log composite score calculation

- [ ] Determine risk grade (AC: 8)
  - [ ] Get grade thresholds from Vault configuration
  - [ ] Find grade where composite score falls within min/max range
  - [ ] Return risk grade (A, B, C, D, F)
  - [ ] Handle edge cases (score = threshold boundary)

- [ ] Determine decision (AC: 9)
  - [ ] Get decision matrix from Vault configuration
  - [ ] Map risk grade to decision using matrix
  - [ ] Return decision (Approved | Conditional | ManualReview | Rejected)
  - [ ] Log decision with risk grade

- [ ] Generate evaluation results (AC: 10)
  - [ ] Create `RuleEvaluationResult` model
  - [ ] Include list of all rules evaluated
  - [ ] For each rule: ID, name, passed, score, weight, weighted score
  - [ ] Include composite score, risk grade, decision
  - [ ] Include configuration version used

- [ ] Test rule engine
  - [ ] Unit test expression evaluation
  - [ ] Unit test rule evaluation logic
  - [ ] Unit test composite scoring
  - [ ] Unit test grade determination
  - [ ] Integration test with real Vault config

## Dev Notes

### Rule Engine Implementation
[Source: docs/domains/credit-assessment/brownfield-architecture.md#Vault-Based Rule Engine Design]

```csharp
public class VaultRuleEngine : IRuleEngine
{
    private readonly IVaultConfigService _vaultConfig;
    private readonly ILogger<VaultRuleEngine> _logger;

    public async Task<RuleEvaluationResult> EvaluateRulesAsync(
        CreditAssessmentRequest request,
        ClientData clientData,
        CreditBureauData bureauData,
        AffordabilityResult affordability)
    {
        var config = await _vaultConfig.GetConfigurationAsync();
        var productType = request.ProductType.ToLower();
        var rules = config.Rules[productType].Where(r => r.IsActive);

        var context = BuildEvaluationContext(request, clientData, bureauData, affordability);
        
        var result = new RuleEvaluationResult
        {
            CompositeScore = 0,
            RuleEvaluations = new List<SingleRuleEvaluation>(),
            ConfigVersion = config.Version
        };

        foreach (var rule in rules)
        {
            var evaluation = EvaluateRule(rule, context);
            result.RuleEvaluations.Add(evaluation);
            result.CompositeScore += evaluation.WeightedScore;
        }

        // Determine risk grade
        result.RiskGrade = DetermineRiskGrade(result.CompositeScore, config.GradeThresholds);
        
        // Determine decision
        result.Decision = config.DecisionMatrix[result.RiskGrade];

        _logger.LogInformation(
            "Rules evaluated: Composite Score {Score}, Grade {Grade}, Decision {Decision}",
            result.CompositeScore, result.RiskGrade, result.Decision);

        return result;
    }

    private Dictionary<string, object> BuildEvaluationContext(
        CreditAssessmentRequest request,
        ClientData clientData,
        CreditBureauData bureauData,
        AffordabilityResult affordability)
    {
        return new Dictionary<string, object>
        {
            ["requestedAmount"] = request.RequestedAmount,
            ["termMonths"] = request.TermMonths,
            ["monthlyIncome"] = clientData.MonthlyIncome,
            ["creditScore"] = bureauData?.CreditScore ?? 0,
            ["existingDebt"] = bureauData?.TotalDebt ?? 0,
            ["debtToIncomeRatio"] = affordability.DebtToIncomeRatio,
            ["disposableIncome"] = affordability.DisposableIncome,
            ["employmentMonths"] = clientData.EmploymentTenureMonths,
            ["existingExposure"] = clientData.ExistingLoanBalance
        };
    }

    private SingleRuleEvaluation EvaluateRule(ScoringRuleConfig rule, Dictionary<string, object> context)
    {
        var passed = EvaluateCondition(rule.Condition, context);
        var score = passed ? rule.PassScore : rule.FailScore;
        var weightedScore = score * rule.Weight;

        return new SingleRuleEvaluation
        {
            RuleId = rule.RuleId,
            RuleName = rule.Name,
            Passed = passed,
            Score = score,
            Weight = rule.Weight,
            WeightedScore = weightedScore,
            Explanation = GenerateRuleExplanation(rule, passed, context)
        };
    }

    private bool EvaluateCondition(RuleCondition condition, Dictionary<string, object> context)
    {
        // Evaluate expression
        var expression = new Expression(condition.Expression);
        
        foreach (var kvp in context)
        {
            expression.Parameters[kvp.Key] = kvp.Value;
        }

        var value = Convert.ToDecimal(expression.Evaluate());
        var threshold = condition.Threshold;

        return condition.Operator switch
        {
            "<=" => value <= threshold,
            ">=" => value >= threshold,
            "<" => value < threshold,
            ">" => value > threshold,
            "==" => Math.Abs(value - threshold) < 0.01m,
            _ => throw new InvalidOperationException($"Unknown operator: {condition.Operator}")
        };
    }

    private string DetermineRiskGrade(decimal compositeScore, Dictionary<string, GradeThreshold> gradeThresholds)
    {
        foreach (var grade in gradeThresholds.OrderByDescending(g => g.Value.MinScore))
        {
            if (compositeScore >= grade.Value.MinScore && compositeScore <= grade.Value.MaxScore)
            {
                return grade.Key;
            }
        }

        return "F"; // Default to F if no match
    }
}
```

### Evaluation Context
[Source: docs/domains/credit-assessment/prd.md#FR7]

The evaluation context provides all variables that can be used in rule expressions:

```csharp
public class RuleEvaluationContext
{
    // Request data
    public decimal RequestedAmount { get; set; }
    public int TermMonths { get; set; }
    public string ProductType { get; set; }

    // Client data
    public decimal MonthlyIncome { get; set; }
    public int EmploymentMonths { get; set; }
    public decimal ExistingExposure { get; set; }

    // Bureau data
    public decimal CreditScore { get; set; }
    public decimal ExistingDebt { get; set; }
    public int ActiveAccounts { get; set; }
    public int DelinquentAccounts { get; set; }

    // Affordability data
    public decimal DebtToIncomeRatio { get; set; }
    public decimal DisposableIncome { get; set; }
    public decimal ProposedPayment { get; set; }
}
```

### Rule Evaluation Models
[Source: docs/domains/credit-assessment/prd.md#FR23]

```csharp
public class RuleEvaluationResult
{
    public string ConfigVersion { get; set; }
    public List<SingleRuleEvaluation> RuleEvaluations { get; set; }
    public decimal CompositeScore { get; set; }
    public string RiskGrade { get; set; }
    public string Decision { get; set; }
}

public class SingleRuleEvaluation
{
    public string RuleId { get; set; }
    public string RuleName { get; set; }
    public bool Passed { get; set; }
    public decimal Score { get; set; }
    public decimal Weight { get; set; }
    public decimal WeightedScore { get; set; }
    public string Explanation { get; set; }
    public Dictionary<string, object> InputValues { get; set; }
}
```

### Expression Evaluation Examples
[Source: docs/domains/credit-assessment/prd.md#FR7]

**Example 1**: Loan-to-Income Ratio
- Expression: `requestedAmount / monthlyIncome`
- Context: requestedAmount = 50000, monthlyIncome = 10000
- Evaluated Value: 5.0
- Operator: `<=`
- Threshold: 10.0
- Result: **Pass** (5.0 <= 10.0)

**Example 2**: Debt-to-Income Ratio
- Expression: `(existingDebt + proposedPayment) / monthlyIncome`
- Context: existingDebt = 2000, proposedPayment = 2500, monthlyIncome = 10000
- Evaluated Value: 0.45
- Operator: `<=`
- Threshold: 0.40
- Result: **Fail** (0.45 > 0.40)

### Integration Verification Requirements
[Source: docs/domains/credit-assessment/prd.md Story 1.9]

**IV1**: Rule engine produces same risk grades as existing DMN decision table for test cases  
**IV2**: Composite scoring calculation is accurate for payroll and business product rules  
**IV3**: Vault configuration changes (e.g., increasing DTI threshold from 40% to 45%) reflected in assessments after configuration refresh

### Testing

#### Unit Tests
- Expression evaluator handles all operators correctly
- Rule evaluation logic calculates scores properly
- Composite score summing is accurate
- Risk grade determination matches thresholds
- Decision matrix mapping works correctly

#### Integration Tests
- End-to-end rule evaluation with Vault configuration
- Payroll product rules evaluate correctly
- Business product rules evaluate correctly
- Configuration changes reflected after refresh

#### Parity Tests
- Compare old DMN decision table results with new rule engine
- Verify 100% match for test cases
- Document any intentional differences

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
(To be populated by development agent)

### Debug Log References
(To be populated by development agent)

### Completion Notes List
(To be populated by development agent)

### File List
(To be populated by development agent)

## QA Results
(To be populated by QA agent)
