# Story 1.15: Feature Flag Implementation for Gradual Rollout

## Status
Draft

## Story
**As a** DevOps Engineer  
**I want** to implement feature flags for credit assessment features  
**so that** new functionality can be rolled out gradually with zero-downtime and easy rollback

## Acceptance Criteria

1. Integrate feature flag library (LaunchDarkly or similar)
2. Create feature flags for: credit bureau integration, PMEC checks, new rule engine
3. Implement flag evaluation at runtime with user/context targeting
4. Default to legacy behavior when flag is disabled
5. Support percentage-based rollouts (e.g., enable for 10% of users)
6. Provide admin API to query current flag states
7. Log flag evaluation decisions for debugging
8. Cache flag values with 30-second TTL to reduce latency
9. Handle flag service unavailability gracefully (use cached/default values)
10. Create monitoring dashboard for flag usage metrics

## Tasks / Subtasks

- [ ] Setup feature flag service (AC: 1)
  - [ ] Add LaunchDarkly SDK NuGet package
  - [ ] Configure SDK key and environment
  - [ ] Initialize client at startup
  - [ ] Add health check for flag service

- [ ] Create feature flags (AC: 2)
  - [ ] Create `credit-bureau-integration-enabled` flag
  - [ ] Create `pmec-checks-enabled` flag
  - [ ] Create `new-rule-engine-enabled` flag
  - [ ] Set default values to `false`

- [ ] Implement flag evaluation (AC: 3)
  - [ ] Create `IFeatureFlagService` interface
  - [ ] Implement `LaunchDarklyFeatureFlagService`
  - [ ] Support user context (userId, userSegment)
  - [ ] Support custom attributes for targeting

- [ ] Add conditional logic (AC: 4)
  - [ ] Wrap new credit bureau calls with flag check
  - [ ] Wrap PMEC integration with flag check
  - [ ] Wrap new rule engine with flag check
  - [ ] Fall back to legacy logic when disabled

- [ ] Support percentage rollouts (AC: 5)
  - [ ] Configure flags for percentage-based targeting
  - [ ] Test 10%, 50%, 100% rollout scenarios
  - [ ] Ensure consistent evaluation for same user

- [ ] Create flag query API (AC: 6)
  - [ ] Create `GET /api/v1/admin/feature-flags` endpoint
  - [ ] Return all flags and their current state
  - [ ] Require admin authorization

- [ ] Add logging (AC: 7)
  - [ ] Log when flag evaluated
  - [ ] Log flag state and targeting context
  - [ ] Use structured logging

- [ ] Implement caching (AC: 8)
  - [ ] Cache flag values in memory
  - [ ] Set TTL to 30 seconds
  - [ ] Refresh on cache miss

- [ ] Handle unavailability (AC: 9)
  - [ ] Catch exceptions from flag service
  - [ ] Use cached value if available
  - [ ] Use default value if no cache
  - [ ] Log fallback events

- [ ] Create monitoring dashboard (AC: 10)
  - [ ] Track flag evaluation count
  - [ ] Track flag state distribution
  - [ ] Alert on flag service errors
  - [ ] Add to Grafana

## Dev Notes

### Feature Flag Service Interface
[Source: docs/domains/credit-assessment/prd.md#FR18]

```csharp
public interface IFeatureFlagService
{
    Task<bool> IsEnabledAsync(string flagKey, FeatureFlagContext context = null);
    Task<T> GetVariationAsync<T>(string flagKey, T defaultValue, FeatureFlagContext context = null);
}

public class FeatureFlagContext
{
    public string UserId { get; set; }
    public string UserSegment { get; set; }
    public Dictionary<string, object> CustomAttributes { get; set; }
}
```

### LaunchDarkly Implementation
[Source: docs/domains/credit-assessment/brownfield-architecture.md#Feature Flags]

```csharp
public class LaunchDarklyFeatureFlagService : IFeatureFlagService
{
    private readonly LdClient _client;
    private readonly IMemoryCache _cache;
    private readonly ILogger<LaunchDarklyFeatureFlagService> _logger;

    public async Task<bool> IsEnabledAsync(string flagKey, FeatureFlagContext context = null)
    {
        var cacheKey = $"flag:{flagKey}:{context?.UserId}";
        
        if (_cache.TryGetValue(cacheKey, out bool cachedValue))
        {
            return cachedValue;
        }

        try
        {
            var user = context != null ? BuildUser(context) : User.WithKey("anonymous");
            var result = _client.BoolVariation(flagKey, user, defaultValue: false);
            
            _cache.Set(cacheKey, result, TimeSpan.FromSeconds(30));
            
            _logger.LogInformation(
                "Feature flag evaluated: {FlagKey} = {Result} for user {UserId}",
                flagKey, result, context?.UserId ?? "anonymous");
            
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to evaluate feature flag {FlagKey}, using default", flagKey);
            return false; // Default to disabled on error
        }
    }

    private User BuildUser(FeatureFlagContext context)
    {
        var userBuilder = User.Builder(context.UserId);
        
        if (!string.IsNullOrEmpty(context.UserSegment))
        {
            userBuilder.Custom("segment", context.UserSegment);
        }

        if (context.CustomAttributes != null)
        {
            foreach (var attr in context.CustomAttributes)
            {
                userBuilder.Custom(attr.Key, attr.Value);
            }
        }

        return userBuilder.Build();
    }
}
```

### Conditional Feature Usage
[Source: docs/domains/credit-assessment/prd.md Story 1.15]

```csharp
public async Task<CreditAssessment> AssessAsync(AssessmentRequest request)
{
    var flagContext = new FeatureFlagContext
    {
        UserId = request.ClientId.ToString(),
        UserSegment = request.ClientSegment
    };

    // Check if new credit bureau integration should be used
    var useCreditBureau = await _featureFlagService.IsEnabledAsync(
        "credit-bureau-integration-enabled",
        flagContext);

    CreditBureauData bureauData;
    if (useCreditBureau)
    {
        bureauData = await _transUnionClient.GetCreditReportAsync(request.ClientId);
    }
    else
    {
        bureauData = await _legacyCreditCheckService.GetCreditDataAsync(request.ClientId);
    }

    // Similar checks for other features
    var usePMEC = await _featureFlagService.IsEnabledAsync("pmec-checks-enabled", flagContext);
    var useNewRuleEngine = await _featureFlagService.IsEnabledAsync("new-rule-engine-enabled", flagContext);

    // Continue with assessment logic...
}
```

### Integration Verification Requirements
[Source: docs/domains/credit-assessment/prd.md Story 1.15]

**IV1**: Feature can be enabled/disabled without code deployment  
**IV2**: Percentage-based rollout works correctly (10% of users get new feature)  
**IV3**: When feature flag service unavailable, system falls back gracefully  
**IV4**: Flag state changes propagate to all instances within 30 seconds

### Testing

#### Unit Tests
- Flag evaluation returns correct values
- Caching works correctly (cache hit/miss)
- Fallback to default on error
- User context passed correctly

#### Integration Tests
- LaunchDarkly SDK integration works
- Flags control feature behavior
- Percentage rollouts distribute correctly
- Cache TTL expires appropriately
- Service unavailability handled gracefully

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
(To be populated by development agent)

### Debug Log References
(To be populated by development agent)

### Completion Notes List
(To be populated by development agent)

### File List
(To be populated by development agent)

## QA Results
(To be populated by QA agent)
