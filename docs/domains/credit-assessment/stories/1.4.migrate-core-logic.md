# Story 1.4: Migrate Core Credit Assessment Logic with Parity

## Status
Draft

## Story
**As a** Backend Developer  
**I want** to migrate the existing `CreditAssessmentService` logic to the new microservice  
**so that** the new service has functional parity with the embedded implementation

## Acceptance Criteria

1. Copy and refactor `CreditAssessmentService.cs` from Loan Origination Service
2. Copy and adapt `RiskCalculationEngine.cs` (keeping hard-coded rules temporarily)
3. Implement `AffordabilityAnalysisService` with DTI calculation logic
4. Create repository pattern for `CreditAssessment` entity data access
5. Implement basic credit bureau data retrieval (mocked initially)
6. Implement affordability assessment logic
7. Implement risk calculation and grade determination
8. Generate assessment result with explanation
9. Persist assessment to database
10. Return structured `AssessmentResponse` with decision payload

## Tasks / Subtasks

- [ ] Create repository for database access (AC: 4)
  - [ ] Create `Data/Repositories/ICreditAssessmentRepository.cs` interface
  - [ ] Create `Data/Repositories/CreditAssessmentRepository.cs` implementation
  - [ ] Implement `CreateAsync`, `GetByIdAsync`, `GetLatestForClientAsync` methods
  - [ ] Register repository in dependency injection

- [ ] Migrate CreditAssessmentService (AC: 1)
  - [ ] Locate existing service: `apps/IntelliFin.LoanOriginationService/Services/CreditAssessmentService.cs`
  - [ ] Copy to `Services/Core/CreditAssessmentService.cs` in new project
  - [ ] Update namespace and dependencies
  - [ ] Remove Loan Origination specific dependencies
  - [ ] Adapt to use repository pattern instead of direct DbContext
  - [ ] Update method signatures to match new DTOs

- [ ] Migrate RiskCalculationEngine (AC: 2)
  - [ ] Copy `RiskCalculationEngine.cs` to `Services/Core/RiskCalculationEngine.cs`
  - [ ] Keep hard-coded rules intact (will be replaced in Story 1.9)
  - [ ] Update to work with new data models
  - [ ] Ensure DTI, credit score, and other calculations match existing logic
  - [ ] Add logging for rule evaluations

- [ ] Implement AffordabilityAnalysisService (AC: 3, 6)
  - [ ] Create `Services/Core/AffordabilityAnalysisService.cs`
  - [ ] Implement DTI calculation: `(existingDebt + proposedPayment) / monthlyIncome`
  - [ ] Calculate maximum affordable payment based on income and existing obligations
  - [ ] Calculate recommended loan amount
  - [ ] Return `AffordabilityResult` with disposable income details

- [ ] Implement credit bureau data retrieval (AC: 5)
  - [ ] Create `Services/Integration/CreditBureauService.cs`
  - [ ] Implement mocked bureau data retrieval (use dictionary like existing code)
  - [ ] Return mock data structure matching existing `CreditBureauData`
  - [ ] Add logging for bureau data access
  - [ ] Prepare structure for real TransUnion integration (Story 1.6)

- [ ] Implement core assessment orchestration (AC: 7, 8, 9, 10)
  - [ ] Update `CreditAssessmentService.PerformAssessmentAsync` method
  - [ ] Step 1: Retrieve credit bureau data (mocked)
  - [ ] Step 2: Perform affordability analysis
  - [ ] Step 3: Calculate risk score using RiskCalculationEngine
  - [ ] Step 4: Determine risk grade (A-F)
  - [ ] Step 5: Generate explanation text
  - [ ] Step 6: Create `CreditAssessment` entity
  - [ ] Step 7: Persist to database via repository
  - [ ] Step 8: Map entity to `AssessmentResponse` DTO
  - [ ] Step 9: Return response to controller

- [ ] Implement explanation generation (AC: 8)
  - [ ] Create `Services/Core/ExplanationService.cs`
  - [ ] Generate human-readable explanation from risk factors
  - [ ] Include DTI ratio, credit score, and key factors
  - [ ] Format as markdown text
  - [ ] Match existing explanation format for backward compatibility

- [ ] Test functional parity (AC: All)
  - [ ] Unit test each service component
  - [ ] Create integration test comparing old vs new service output
  - [ ] Use same input data for both implementations
  - [ ] Verify risk grades match
  - [ ] Verify DTI calculations match
  - [ ] Verify decision outcomes match

## Dev Notes

### Existing Implementation Location
[Source: docs/domains/credit-assessment/brownfield-architecture.md#Quick Reference]

**Current Files**:
- Service: `apps/IntelliFin.LoanOriginationService/Services/CreditAssessmentService.cs`
- Risk Engine: `apps/IntelliFin.LoanOriginationService/Services/RiskCalculationEngine.cs`
- DMN Rules: `apps/IntelliFin.LoanOriginationService/BPMN/risk-grade-decision.dmn`
- Entity: `libs/IntelliFin.Shared.DomainModels/Entities/CreditAssessment.cs`

### Current Flow
[Source: docs/domains/credit-assessment/brownfield-architecture.md#Existing Credit Assessment Logic]

1. Get loan application details (mocked)
2. Get credit bureau data (mocked from dictionary)
3. Assess affordability (basic DTI calculation)
4. Calculate risk via `RiskCalculationEngine`
5. Generate explanation
6. Return `CreditAssessment` entity

### DTI Calculation Formula
[Source: docs/domains/credit-assessment/prd.md#FR10]

```csharp
public decimal CalculateDebtToIncomeRatio(decimal monthlyIncome, decimal existingDebt, decimal proposedPayment)
{
    var totalDebt = existingDebt + proposedPayment;
    return totalDebt / monthlyIncome;
}
```

### Affordability Analysis
[Source: docs/domains/credit-assessment/prd.md#FR11]

```csharp
public class AffordabilityResult
{
    public decimal MonthlyIncome { get; set; }
    public decimal ExistingObligations { get; set; }
    public decimal ProposedPayment { get; set; }
    public decimal DebtToIncomeRatio { get; set; }
    public decimal DisposableIncome { get; set; }
    public decimal MaxAffordablePayment { get; set; }
    public decimal RecommendedLoanAmount { get; set; }
    public bool IsAffordable { get; set; }
}

public AffordabilityResult AnalyzeAffordability(
    decimal monthlyIncome,
    decimal existingDebt,
    decimal requestedAmount,
    int termMonths,
    decimal interestRate)
{
    var proposedPayment = CalculateMonthlyPayment(requestedAmount, termMonths, interestRate);
    var dti = (existingDebt + proposedPayment) / monthlyIncome;
    var maxDTI = 0.40m; // 40% threshold
    var disposableIncome = monthlyIncome - existingDebt - proposedPayment;
    var maxAffordablePayment = (monthlyIncome * maxDTI) - existingDebt;
    var isAffordable = dti <= maxDTI && disposableIncome >= 0;
    
    return new AffordabilityResult
    {
        MonthlyIncome = monthlyIncome,
        ExistingObligations = existingDebt,
        ProposedPayment = proposedPayment,
        DebtToIncomeRatio = dti,
        DisposableIncome = disposableIncome,
        MaxAffordablePayment = maxAffordablePayment,
        IsAffordable = isAffordable
    };
}
```

### Risk Grade Determination
[Source: docs/domains/credit-assessment/brownfield-architecture.md#Appendix A]

Current DMN Logic:
- Grade A: Credit Score >= 750, DTI <= 30%
- Grade B: Credit Score 650-749, DTI <= 40%
- Grade C: Credit Score 550-649, DTI <= 50%
- Grade D: Credit Score 450-549, DTI <= 40%
- Grade F: Credit Score < 350 OR DTI > 60%

```csharp
public string DetermineRiskGrade(decimal creditScore, decimal dtiRatio)
{
    if (creditScore >= 750 && dtiRatio <= 0.30m) return "A";
    if (creditScore >= 650 && dtiRatio <= 0.40m) return "B";
    if (creditScore >= 550 && dtiRatio <= 0.50m) return "C";
    if (creditScore >= 450 && dtiRatio <= 0.40m) return "D";
    return "F";
}
```

### Mocked Credit Bureau Data
[Source: docs/domains/credit-assessment/brownfield-architecture.md#Technical Debt]

```csharp
// Temporary mock - will be replaced in Story 1.6
public class CreditBureauService : ICreditBureauService
{
    private readonly Dictionary<string, CreditBureauData> _mockData = new()
    {
        ["test-nrc-001"] = new CreditBureauData
        {
            CreditScore = 720,
            HasHistory = true,
            TotalDebt = 15000,
            ActiveAccounts = 2,
            DelinquentAccounts = 0
        }
    };

    public async Task<CreditBureauData> GetCreditDataAsync(string nrc)
    {
        await Task.Delay(100); // Simulate API call
        return _mockData.GetValueOrDefault(nrc) ?? new CreditBureauData
        {
            CreditScore = 600,
            HasHistory = false
        };
    }
}
```

### Repository Pattern
[Source: docs/domains/credit-assessment/prd.md#3.2 Integration Approach]

```csharp
public interface ICreditAssessmentRepository
{
    Task<CreditAssessment> CreateAsync(CreditAssessment assessment);
    Task<CreditAssessment?> GetByIdAsync(Guid id);
    Task<CreditAssessment?> GetLatestForClientAsync(Guid clientId);
    Task<List<CreditAssessment>> GetByLoanApplicationIdAsync(Guid loanApplicationId);
    Task<CreditAssessment> UpdateAsync(CreditAssessment assessment);
}

public class CreditAssessmentRepository : ICreditAssessmentRepository
{
    private readonly LmsDbContext _context;
    private readonly ILogger<CreditAssessmentRepository> _logger;

    public async Task<CreditAssessment> CreateAsync(CreditAssessment assessment)
    {
        _context.CreditAssessments.Add(assessment);
        await _context.SaveChangesAsync();
        return assessment;
    }

    public async Task<CreditAssessment?> GetLatestForClientAsync(Guid clientId)
    {
        return await _context.CreditAssessments
            .Where(a => a.ClientId == clientId)
            .OrderByDescending(a => a.AssessedAt)
            .FirstOrDefaultAsync();
    }
}
```

### Explanation Generation
[Source: docs/domains/credit-assessment/prd.md#FR12]

```csharp
public string GenerateExplanation(CreditAssessment assessment, AffordabilityResult affordability)
{
    var sb = new StringBuilder();
    sb.AppendLine($"**Risk Grade: {assessment.RiskGrade}**");
    sb.AppendLine();
    sb.AppendLine($"Credit Score: {assessment.CreditScore}");
    sb.AppendLine($"Debt-to-Income Ratio: {affordability.DebtToIncomeRatio:P2}");
    sb.AppendLine($"Monthly Income: ZMW {affordability.MonthlyIncome:N2}");
    sb.AppendLine($"Existing Obligations: ZMW {affordability.ExistingObligations:N2}");
    sb.AppendLine($"Proposed Payment: ZMW {affordability.ProposedPayment:N2}");
    sb.AppendLine($"Disposable Income: ZMW {affordability.DisposableIncome:N2}");
    sb.AppendLine();
    
    if (affordability.IsAffordable)
    {
        sb.AppendLine("✓ Application is affordable based on income and existing obligations");
    }
    else
    {
        sb.AppendLine("✗ Application exceeds affordable payment capacity");
    }
    
    return sb.ToString();
}
```

### Integration Verification Requirements
[Source: docs/domains/credit-assessment/prd.md Story 1.4]

**IV1**: Assessment results match output from existing embedded service (verified with same input data)  
**IV2**: Risk grades calculated are identical to DMN decision table results for test cases  
**IV3**: Database records written have same structure as existing assessments (backward compatible)

### Testing

#### Unit Tests
- AffordabilityAnalysisService calculates DTI correctly
- RiskCalculationEngine determines correct risk grades
- ExplanationService generates readable text
- Repository methods persist and retrieve correctly

#### Integration Tests
- End-to-end assessment flow produces correct results
- Assessment entity saved to database with all fields
- Results match existing service output for same inputs

#### Parity Testing
- Create test suite with 20+ loan application scenarios
- Run through both old and new implementations
- Compare risk grades, DTI ratios, decisions
- Verify 100% match for all test cases

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
(To be populated by development agent)

### Debug Log References
(To be populated by development agent)

### Completion Notes List
(To be populated by development agent)

### File List
(To be populated by development agent)

## QA Results
(To be populated by QA agent)
