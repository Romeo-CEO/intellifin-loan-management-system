# Story 1.1: Credit Assessment Service Scaffolding and Infrastructure Setup

## Status
Draft

## Story
**As a** DevOps Engineer  
**I want** to create the Credit Assessment Service project structure with deployment configuration  
**so that** the new microservice has a solid foundation matching IntelliFin's infrastructure standards

## Acceptance Criteria

1. Create new ASP.NET Core 8.0 project `IntelliFin.CreditAssessmentService` in `apps/` directory
2. Configure shared `LmsDbContext` reference from `IntelliFin.Shared.DomainModels`
3. Set up dependency injection with Serilog, Prometheus metrics, health checks
4. Create Dockerfile with multi-stage build (build → test → runtime)
5. Create Kubernetes deployment manifest and Helm chart with ConfigMap and secrets
6. Configure appsettings.json with environment-specific configuration sections
7. Implement health check endpoints (`/health/live`, `/health/ready`)
8. Add Prometheus metrics endpoint (`/metrics`) with basic HTTP request metrics
9. Create README.md with setup instructions and architecture overview
10. Successfully deploy to development Kubernetes cluster and verify health checks

## Tasks / Subtasks

- [ ] Create ASP.NET Core 8.0 project structure (AC: 1)
  - [ ] Run `dotnet new webapi -n IntelliFin.CreditAssessmentService` in `apps/` directory
  - [ ] Configure project to use .NET 8.0 framework
  - [ ] Add project reference to `libs/IntelliFin.Shared.DomainModels`
  - [ ] Remove default WeatherForecast controller and models

- [ ] Configure dependency injection and middleware (AC: 2, 3)
  - [ ] Add NuGet packages: `Serilog.AspNetCore`, `prometheus-net.AspNetCore`, `Microsoft.EntityFrameworkCore.Design`
  - [ ] Register `LmsDbContext` in `Program.cs` with PostgreSQL connection string from configuration
  - [ ] Configure Serilog with JSON formatter and structured logging
  - [ ] Add Prometheus metrics middleware to pipeline
  - [ ] Configure CORS, authentication middleware (JWT bearer), authorization

- [ ] Implement health check endpoints (AC: 7)
  - [ ] Add health checks NuGet package: `Microsoft.Extensions.Diagnostics.HealthChecks`
  - [ ] Create `/health/live` endpoint returning 200 OK (liveness probe)
  - [ ] Create `/health/ready` endpoint with database connectivity check (readiness probe)
  - [ ] Configure health check response format (JSON with status and checks)

- [ ] Add Prometheus metrics endpoint (AC: 8)
  - [ ] Expose `/metrics` endpoint using `prometheus-net` library
  - [ ] Configure basic HTTP request metrics (request count, duration, response status)
  - [ ] Add custom metrics placeholders for assessment-specific metrics

- [ ] Create Dockerfile with multi-stage build (AC: 4)
  - [ ] Stage 1: Build - restore dependencies, compile, run tests
  - [ ] Stage 2: Publish - create optimized release build
  - [ ] Stage 3: Runtime - use `mcr.microsoft.com/dotnet/aspnet:8.0` base image
  - [ ] Configure non-root user for security
  - [ ] Expose port 8080 for HTTP traffic

- [ ] Create Kubernetes deployment manifests (AC: 5)
  - [ ] Create `deployment.yaml` with resource limits, liveness/readiness probes
  - [ ] Create `service.yaml` for ClusterIP service
  - [ ] Create `configmap.yaml` for non-sensitive configuration
  - [ ] Create `secrets.yaml` template for sensitive data (Vault tokens, database passwords)
  - [ ] Create basic Helm chart structure with values.yaml

- [ ] Configure appsettings.json (AC: 6)
  - [ ] Add ConnectionStrings section for PostgreSQL (LmsDatabase)
  - [ ] Add Redis configuration section
  - [ ] Add RabbitMQ configuration section
  - [ ] Add Vault configuration section (address, token path, rules path)
  - [ ] Add ExternalServices section (ClientManagement, AdminService, TransUnion, PMEC)
  - [ ] Add Camunda configuration (Zeebe gateway address, worker name)
  - [ ] Create environment-specific overrides: `appsettings.Development.json`, `appsettings.Production.json`

- [ ] Create README.md documentation (AC: 9)
  - [ ] Document service purpose and architectural overview
  - [ ] Document local development setup instructions
  - [ ] Document environment variables and configuration requirements
  - [ ] Document API endpoints (to be implemented)
  - [ ] Document deployment instructions

- [ ] Deploy to development Kubernetes cluster (AC: 10)
  - [ ] Build Docker image and push to container registry
  - [ ] Apply Kubernetes manifests to dev cluster
  - [ ] Verify pod is running and healthy
  - [ ] Test `/health/live` and `/health/ready` endpoints return 200 OK
  - [ ] Test `/metrics` endpoint returns Prometheus metrics
  - [ ] Verify service is discoverable by other services in cluster

## Dev Notes

### Project Structure
[Source: docs/domains/credit-assessment/prd.md#3.3 Code Organization and Standards]

```
apps/IntelliFin.CreditAssessmentService/
├── Controllers/          # REST API endpoints (to be added in later stories)
├── Services/            
│   ├── Core/            # Core business logic (future)
│   ├── Integration/     # External service clients (future)
│   ├── Configuration/   # Vault and config management (future)
│   └── Events/          # Event handlers (future)
├── Workers/             # Camunda external task workers (future)
├── Models/              # DTOs and request/response models (future)
│   ├── Requests/
│   ├── Responses/
│   └── Configuration/
├── Data/
│   └── Repositories/    # Data access layer (future)
├── BPMN/                # Workflow definitions (future)
├── Dockerfile
├── appsettings.json
├── Program.cs
└── README.md
```

### Technology Stack
[Source: docs/domains/credit-assessment/prd.md#3.1 Existing Technology Stack]
- **Runtime**: .NET 8.0
- **Framework**: ASP.NET Core 8.0 (Minimal APIs recommended)
- **Database**: PostgreSQL 15 with Entity Framework Core
- **Logging**: Serilog with structured JSON output
- **Metrics**: Prometheus with `prometheus-net.AspNetCore`
- **Container**: Docker with multi-stage build
- **Orchestration**: Kubernetes with Helm

### Database Context Configuration
[Source: docs/domains/credit-assessment/brownfield-architecture.md#Data Models and APIs]

The service will share the `LmsDbContext` from `IntelliFin.Shared.DomainModels`. Register it with:

```csharp
builder.Services.AddDbContext<LmsDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("LmsDatabase")));
```

### Health Checks Configuration
[Source: docs/domains/credit-assessment/prd.md#NFR11]

Implement two health check endpoints:
- **Liveness** (`/health/live`): Simple 200 OK response (service is running)
- **Readiness** (`/health/ready`): Check database connectivity, critical dependencies

Example configuration:
```csharp
builder.Services.AddHealthChecks()
    .AddNpgSql(builder.Configuration.GetConnectionString("LmsDatabase"), 
               name: "database", 
               tags: new[] { "ready" });

app.MapHealthChecks("/health/live", new HealthCheckOptions { Predicate = _ => false });
app.MapHealthChecks("/health/ready", new HealthCheckOptions { Predicate = check => check.Tags.Contains("ready") });
```

### Prometheus Metrics
[Source: docs/domains/credit-assessment/prd.md#NFR10]

Expose `/metrics` endpoint with:
- HTTP request count
- HTTP request duration histogram (p50, p95, p99)
- HTTP response status codes

Use `prometheus-net.AspNetCore` middleware:
```csharp
app.UseMetricServer();  // Exposes /metrics
app.UseHttpMetrics();   // Collects HTTP metrics
```

### Deployment Configuration
[Source: docs/domains/credit-assessment/prd.md#3.4 Deployment and Operations]

**Kubernetes Deployment Requirements**:
- Resource requests: CPU 100m, Memory 256Mi
- Resource limits: CPU 500m, Memory 512Mi
- Liveness probe: HTTP GET `/health/live` every 30s
- Readiness probe: HTTP GET `/health/ready` every 10s
- Rolling update strategy: maxSurge 1, maxUnavailable 0

**Environment Variables**:
- `ASPNETCORE_ENVIRONMENT`: Development | Staging | Production
- `ConnectionStrings__LmsDatabase`: PostgreSQL connection string (from secret)
- `Vault__Address`: Vault server address
- `Vault__Token`: Vault authentication token (from secret)

### Integration Verification Requirements
[Source: docs/domains/credit-assessment/prd.md Story 1.1]

**IV1**: Existing Loan Origination Service continues operating without any changes  
**IV2**: New service deploys successfully alongside existing services without network conflicts  
**IV3**: Health checks respond correctly and service is discoverable by Kubernetes

### Coding Standards
[Source: docs/domains/credit-assessment/prd.md#3.3 Coding Standards]
- PascalCase for classes, methods, properties
- camelCase for local variables, parameters
- Async/await for all I/O operations
- Dependency injection for all service dependencies
- XML documentation comments for public APIs
- Structured logging with contextual information

### Testing

#### Unit Tests
- Health check endpoint returns 200 OK
- Metrics endpoint returns valid Prometheus format
- Database context registration succeeds

#### Integration Tests
- Kubernetes deployment applies without errors
- Service starts and health checks pass within 30 seconds
- Prometheus metrics endpoint accessible from within cluster

#### Manual Testing
- Deploy to dev cluster: `kubectl apply -f k8s/`
- Check pod status: `kubectl get pods -l app=credit-assessment-service`
- Test health: `kubectl port-forward svc/credit-assessment-service 8080:80` → `curl http://localhost:8080/health/ready`
- Test metrics: `curl http://localhost:8080/metrics`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
(To be populated by development agent)

### Debug Log References
(To be populated by development agent)

### Completion Notes List
(To be populated by development agent)

### File List
(To be populated by development agent)

## QA Results
(To be populated by QA agent)
