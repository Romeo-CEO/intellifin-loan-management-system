# Story 1.11: AdminService Audit Trail Integration for Decision Traceability

## Status
Draft

## Story
**As a** Backend Developer  
**I want** to log all credit assessment events to AdminService as structured audit records  
**so that** every decision is traceable for regulatory compliance and forensic analysis

## Acceptance Criteria

1. Create `AdminServiceClient` for audit event publishing
2. Define audit event types: `CreditAssessmentInitiated`, `RuleEvaluated`, `DecisionMade`, `ManualOverrideApplied`, `AssessmentInvalidated`
3. Publish `CreditAssessmentInitiated` event when assessment request received
4. Publish `RuleEvaluated` event for each rule with input/output/result
5. Publish `DecisionMade` event with final risk grade, score, decision, explanation
6. Include user ID, loan application ID, client ID, timestamp in all events
7. Include Vault configuration version in decision events
8. Include correlation ID linking all events for single assessment
9. Implement async fire-and-forget pattern for audit publishing (don't block assessment)
10. Implement dead letter queue for failed audit events with retry logic

## Tasks / Subtasks

- [ ] Create AdminService HTTP client (AC: 1)
  - [ ] Create `Services/Integration/AdminServiceClient.cs`
  - [ ] Configure HTTP client for AdminService base URL
  - [ ] Add authentication with service-to-service token
  - [ ] Implement `PublishAuditEventAsync` method

- [ ] Define audit event models (AC: 2)
  - [ ] Create `Models/Audit/AuditEventBase.cs`
  - [ ] Create `Models/Audit/CreditAssessmentInitiatedEvent.cs`
  - [ ] Create `Models/Audit/RuleEvaluatedEvent.cs`
  - [ ] Create `Models/Audit/DecisionMadeEvent.cs`
  - [ ] Create `Models/Audit/ManualOverrideAppliedEvent.cs`
  - [ ] Create `Models/Audit/AssessmentInvalidatedEvent.cs`

- [ ] Implement assessment initiated event (AC: 3, 6, 8)
  - [ ] Generate correlation ID at start of assessment
  - [ ] Create event with request details
  - [ ] Include user ID from JWT claims
  - [ ] Include loan application ID and client ID
  - [ ] Publish to AdminService

- [ ] Implement rule evaluated events (AC: 4, 6, 8)
  - [ ] For each rule evaluation, create event
  - [ ] Include rule ID, name, passed/failed
  - [ ] Include input values used
  - [ ] Include calculated score and weighted score
  - [ ] Include correlation ID
  - [ ] Publish to AdminService

- [ ] Implement decision made event (AC: 5, 6, 7, 8)
  - [ ] Create event with final assessment result
  - [ ] Include risk grade and composite score
  - [ ] Include decision (Approved/Rejected/etc.)
  - [ ] Include explanation text
  - [ ] Include Vault configuration version
  - [ ] Include correlation ID
  - [ ] Publish to AdminService

- [ ] Implement async fire-and-forget pattern (AC: 9)
  - [ ] Publish audit events asynchronously
  - [ ] Don't await audit publishing in critical path
  - [ ] Use background task or message queue
  - [ ] Log if audit publishing fails but continue assessment
  - [ ] Ensure assessment performance not impacted

- [ ] Implement dead letter queue (AC: 10)
  - [ ] Use RabbitMQ for audit event queue
  - [ ] Configure dead letter exchange
  - [ ] Retry failed events with exponential backoff
  - [ ] Move to DLQ after 3 retries
  - [ ] Alert on DLQ buildup

- [ ] Test audit integration
  - [ ] Unit test event serialization
  - [ ] Integration test with AdminService
  - [ ] Verify correlation IDs link events
  - [ ] Test async fire-and-forget doesn't block
  - [ ] Test DLQ retry logic

## Dev Notes

### AdminService Client Implementation
[Source: docs/domains/credit-assessment/prd.md#FR13]

```csharp
public class AdminServiceClient : IAdminServiceClient
{
    private readonly IHttpClientFactory _httpClientFactory;
    private readonly IBackgroundTaskQueue _taskQueue;
    private readonly ILogger<AdminServiceClient> _logger;

    public async Task PublishAuditEventAsync(AuditEventBase auditEvent)
    {
        // Fire and forget - queue for background processing
        _taskQueue.QueueBackgroundWorkItem(async token =>
        {
            try
            {
                var client = _httpClientFactory.CreateClient("AdminService");
                var response = await client.PostAsJsonAsync("/api/v1/audit/events", auditEvent, token);
                
                if (!response.IsSuccessStatusCode)
                {
                    _logger.LogWarning("Audit event publishing failed: {StatusCode}", response.StatusCode);
                    throw new AuditPublishException($"Status code: {response.StatusCode}");
                }
                
                _logger.LogDebug("Audit event published: {EventType}", auditEvent.EventType);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to publish audit event: {EventType}", auditEvent.EventType);
                // Event will be retried by background queue or moved to DLQ
                throw;
            }
        });
    }
}
```

### Audit Event Models
[Source: docs/domains/credit-assessment/brownfield-architecture.md#AdminService Audit Integration]

```csharp
public abstract class AuditEventBase
{
    public string EventType { get; set; }
    public Guid CorrelationId { get; set; }
    public DateTime Timestamp { get; set; }
    public Guid? UserId { get; set; }
    public Guid? ClientId { get; set; }
    public Guid? LoanApplicationId { get; set; }
}

public class CreditAssessmentInitiatedEvent : AuditEventBase
{
    public decimal RequestedAmount { get; set; }
    public int TermMonths { get; set; }
    public string ProductType { get; set; }
}

public class RuleEvaluatedEvent : AuditEventBase
{
    public string RuleId { get; set; }
    public string RuleName { get; set; }
    public bool Passed { get; set; }
    public decimal Score { get; set; }
    public decimal Weight { get; set; }
    public decimal WeightedScore { get; set; }
    public Dictionary<string, object> InputValues { get; set; }
}

public class DecisionMadeEvent : AuditEventBase
{
    public string Decision { get; set; }
    public string RiskGrade { get; set; }
    public decimal CompositeScore { get; set; }
    public string Explanation { get; set; }
    public string VaultConfigVersion { get; set; }
    public Guid AssessmentId { get; set; }
}

public class ManualOverrideAppliedEvent : AuditEventBase
{
    public Guid AssessmentId { get; set; }
    public string OriginalDecision { get; set; }
    public string OverrideDecision { get; set; }
    public string Reason { get; set; }
    public Guid OverriddenByUserId { get; set; }
}

public class AssessmentInvalidatedEvent : AuditEventBase
{
    public Guid AssessmentId { get; set; }
    public string Reason { get; set; }
    public string TriggerEvent { get; set; }
}
```

### Assessment Flow with Audit Events
[Source: docs/domains/credit-assessment/prd.md#FR13]

```csharp
public async Task<AssessmentResponse> PerformAssessmentAsync(AssessmentRequest request)
{
    var correlationId = Guid.NewGuid();
    
    // 1. Publish Assessment Initiated
    await _auditClient.PublishAuditEventAsync(new CreditAssessmentInitiatedEvent
    {
        EventType = "CreditAssessmentInitiated",
        CorrelationId = correlationId,
        Timestamp = DateTime.UtcNow,
        UserId = _currentUser.Id,
        ClientId = request.ClientId,
        LoanApplicationId = request.LoanApplicationId,
        RequestedAmount = request.RequestedAmount,
        TermMonths = request.TermMonths,
        ProductType = request.ProductType
    });
    
    // 2. Perform assessment
    var ruleResult = await _ruleEngine.EvaluateRulesAsync(...);
    
    // 3. Publish Rule Evaluated events
    foreach (var rule in ruleResult.RuleEvaluations)
    {
        await _auditClient.PublishAuditEventAsync(new RuleEvaluatedEvent
        {
            EventType = "RuleEvaluated",
            CorrelationId = correlationId,
            Timestamp = DateTime.UtcNow,
            UserId = _currentUser.Id,
            ClientId = request.ClientId,
            LoanApplicationId = request.LoanApplicationId,
            RuleId = rule.RuleId,
            RuleName = rule.RuleName,
            Passed = rule.Passed,
            Score = rule.Score,
            Weight = rule.Weight,
            WeightedScore = rule.WeightedScore,
            InputValues = rule.InputValues
        });
    }
    
    // 4. Publish Decision Made
    var assessment = await SaveAssessment(...);
    
    await _auditClient.PublishAuditEventAsync(new DecisionMadeEvent
    {
        EventType = "DecisionMade",
        CorrelationId = correlationId,
        Timestamp = DateTime.UtcNow,
        UserId = _currentUser.Id,
        ClientId = request.ClientId,
        LoanApplicationId = request.LoanApplicationId,
        AssessmentId = assessment.Id,
        Decision = ruleResult.Decision,
        RiskGrade = ruleResult.RiskGrade,
        CompositeScore = ruleResult.CompositeScore,
        Explanation = explanation,
        VaultConfigVersion = _vaultConfig.CurrentVersion
    });
    
    return MapToResponse(assessment);
}
```

### Background Task Queue for Async Publishing
[Source: docs/domains/credit-assessment/prd.md#FR13, AC9]

```csharp
public interface IBackgroundTaskQueue
{
    void QueueBackgroundWorkItem(Func<CancellationToken, Task> workItem);
    Task<Func<CancellationToken, Task>> DequeueAsync(CancellationToken cancellationToken);
}

public class BackgroundTaskQueue : IBackgroundTaskQueue
{
    private readonly Channel<Func<CancellationToken, Task>> _queue;

    public BackgroundTaskQueue(int capacity = 100)
    {
        _queue = Channel.CreateBounded<Func<CancellationToken, Task>>(capacity);
    }

    public void QueueBackgroundWorkItem(Func<CancellationToken, Task> workItem)
    {
        if (!_queue.Writer.TryWrite(workItem))
        {
            throw new InvalidOperationException("Background task queue is full");
        }
    }

    public async Task<Func<CancellationToken, Task>> DequeueAsync(CancellationToken cancellationToken)
    {
        return await _queue.Reader.ReadAsync(cancellationToken);
    }
}
```

### Integration Verification Requirements
[Source: docs/domains/credit-assessment/prd.md Story 1.11]

**IV1**: All assessment events appear in AdminService audit log with correct correlation IDs  
**IV2**: Assessment continues successfully even if AdminService is temporarily unavailable (events queued)  
**IV3**: Event payloads contain sufficient detail for forensic reconstruction of decision

### Testing

#### Unit Tests
- Audit event serialization to JSON works correctly
- Correlation ID is consistent across all events
- Event models contain all required fields

#### Integration Tests
- Events published to AdminService successfully
- Correlation ID links all events for single assessment
- Assessment completes even when AdminService unavailable
- Dead letter queue receives failed events after retries

#### End-to-End Test
- Perform complete assessment
- Query AdminService for all events with correlation ID
- Verify all event types present
- Verify event sequence and timing
- Reconstruct assessment from audit events

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
(To be populated by development agent)

### Debug Log References
(To be populated by development agent)

### Completion Notes List
(To be populated by development agent)

### File List
(To be populated by development agent)

## QA Results
(To be populated by QA agent)
