# Story 1.17: Comprehensive Unit and Integration Testing

## Status
Draft

## Story
**As a** QA Engineer  
**I want** to implement comprehensive test coverage for credit assessment service  
**so that** code quality is maintained and regressions are prevented

## Acceptance Criteria

1. Achieve minimum 80% code coverage for unit tests
2. Create unit tests for all business logic (rule engine, decision logic)
3. Create integration tests for external service clients (TransUnion, PMEC, Vault)
4. Create API integration tests covering all endpoints
5. Implement test fixtures for repeatable test data
6. Create tests for error scenarios and edge cases
7. Implement contract tests for service integrations (Pact or similar)
8. Add tests to CI/CD pipeline with coverage reports
9. Create test data generators for realistic scenarios
10. Document testing strategy and test scenarios

## Tasks / Subtasks

- [ ] Setup testing framework (AC: 1, 8)
  - [ ] Configure xUnit test project
  - [ ] Add Coverlet for code coverage
  - [ ] Integrate with CI/CD pipeline
  - [ ] Configure coverage thresholds

- [ ] Create unit tests for business logic (AC: 2)
  - [ ] Test rule engine evaluation
  - [ ] Test credit score calculation
  - [ ] Test decision logic (approve/reject/manual review)
  - [ ] Test risk level assignment
  - [ ] Test override workflow logic

- [ ] Create external service integration tests (AC: 3)
  - [ ] Mock TransUnion API responses
  - [ ] Test TransUnion client error handling
  - [ ] Mock PMEC API responses
  - [ ] Test PMEC client error handling
  - [ ] Mock Vault API responses
  - [ ] Test Vault client with rule retrieval

- [ ] Create API integration tests (AC: 4)
  - [ ] Test POST /api/v1/assessment (happy path)
  - [ ] Test GET /api/v1/assessment/{id}
  - [ ] Test GET /api/v1/assessment with filters
  - [ ] Test error responses (400, 404, 500)
  - [ ] Test authentication/authorization

- [ ] Implement test fixtures (AC: 5)
  - [ ] Create client test data fixture
  - [ ] Create assessment test data fixture
  - [ ] Create rule engine rule fixtures
  - [ ] Use AutoFixture for data generation

- [ ] Create error scenario tests (AC: 6)
  - [ ] Test external service timeouts
  - [ ] Test external service failures
  - [ ] Test database connection failures
  - [ ] Test invalid input data
  - [ ] Test boundary conditions

- [ ] Implement contract tests (AC: 7)
  - [ ] Add Pact .NET library
  - [ ] Create consumer contract for TransUnion
  - [ ] Create consumer contract for PMEC
  - [ ] Create provider contract for assessment API
  - [ ] Publish contracts to Pact Broker

- [ ] Configure CI/CD integration (AC: 8)
  - [ ] Add test stage to pipeline
  - [ ] Generate coverage reports
  - [ ] Fail build if coverage < 80%
  - [ ] Publish test results

- [ ] Create test data generators (AC: 9)
  - [ ] Generate realistic client data
  - [ ] Generate credit report data
  - [ ] Generate assessment history
  - [ ] Use Bogus library for fake data

- [ ] Document testing strategy (AC: 10)
  - [ ] Document test pyramid approach
  - [ ] Document test scenarios
  - [ ] Document how to run tests
  - [ ] Document mock strategies

## Dev Notes

### Unit Test Example - Rule Engine
[Source: docs/domains/credit-assessment/prd.md#FR9]

```csharp
public class RuleEngineTests
{
    private readonly RuleEngine _ruleEngine;
    private readonly Mock<IVaultClient> _vaultClientMock;

    public RuleEngineTests()
    {
        _vaultClientMock = new Mock<IVaultClient>();
        _ruleEngine = new RuleEngine(_vaultClientMock.Object);
    }

    [Fact]
    public async Task Evaluate_CreditScoreAbove700_ReturnsApproved()
    {
        // Arrange
        var rules = new List<Rule>
        {
            new Rule
            {
                Name = "HighCreditScore",
                Condition = "creditScore > 700",
                Decision = "APPROVED"
            }
        };
        _vaultClientMock.Setup(x => x.GetRulesAsync("credit-rules"))
            .ReturnsAsync(rules);

        var context = new AssessmentContext
        {
            CreditScore = 750,
            LoanAmount = 50000,
            LoanTerm = 12
        };

        // Act
        var result = await _ruleEngine.EvaluateAsync(context);

        // Assert
        Assert.Equal("APPROVED", result.Decision);
        Assert.Single(result.MatchedRules);
        Assert.Equal("HighCreditScore", result.MatchedRules[0].Name);
    }

    [Theory]
    [InlineData(650, "MANUAL_REVIEW")]
    [InlineData(550, "REJECTED")]
    public async Task Evaluate_VariousCreditScores_ReturnsExpectedDecision(
        int creditScore,
        string expectedDecision)
    {
        // Test implementation
    }
}
```

### Integration Test Example - API
[Source: docs/domains/credit-assessment/brownfield-architecture.md#Testing]

```csharp
public class AssessmentApiTests : IClassFixture<WebApplicationFactory<Startup>>
{
    private readonly HttpClient _client;
    private readonly WebApplicationFactory<Startup> _factory;

    public AssessmentApiTests(WebApplicationFactory<Startup> factory)
    {
        _factory = factory;
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task PostAssessment_ValidRequest_ReturnsCreated()
    {
        // Arrange
        var request = new AssessmentRequest
        {
            ClientId = Guid.NewGuid(),
            LoanAmount = 50000,
            LoanTerm = 12
        };

        // Act
        var response = await _client.PostAsJsonAsync("/api/v1/assessment", request);

        // Assert
        response.EnsureSuccessStatusCode();
        Assert.Equal(HttpStatusCode.Created, response.StatusCode);
        
        var assessment = await response.Content.ReadFromJsonAsync<CreditAssessment>();
        Assert.NotNull(assessment);
        Assert.NotEqual(Guid.Empty, assessment.Id);
        Assert.Contains(assessment.Decision, new[] { "APPROVED", "REJECTED", "MANUAL_REVIEW" });
    }

    [Fact]
    public async Task PostAssessment_InvalidClientId_ReturnsBadRequest()
    {
        // Arrange
        var request = new AssessmentRequest
        {
            ClientId = Guid.Empty,
            LoanAmount = 50000,
            LoanTerm = 12
        };

        // Act
        var response = await _client.PostAsJsonAsync("/api/v1/assessment", request);

        // Assert
        Assert.Equal(HttpStatusCode.BadRequest, response.StatusCode);
    }
}
```

### Contract Test Example (Pact)
[Source: docs/domains/credit-assessment/prd.md Story 1.17]

```csharp
public class TransUnionClientContractTests : IClassFixture<PactFixture>
{
    private readonly PactFixture _fixture;

    public TransUnionClientContractTests(PactFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public async Task GetCreditReport_ReturnsValidResponse()
    {
        // Arrange
        var clientId = Guid.NewGuid();
        
        _fixture.MockProviderService
            .Given("A client with credit history exists")
            .UponReceiving("A request for credit report")
            .With(new ProviderServiceRequest
            {
                Method = HttpVerb.Get,
                Path = $"/api/credit-report/{clientId}",
                Headers = new Dictionary<string, object>
                {
                    { "Accept", "application/json" }
                }
            })
            .WillRespondWith(new ProviderServiceResponse
            {
                Status = 200,
                Headers = new Dictionary<string, object>
                {
                    { "Content-Type", "application/json" }
                },
                Body = new
                {
                    creditScore = 720,
                    paymentHistory = "GOOD",
                    outstandingDebts = 15000
                }
            });

        var client = new TransUnionClient(_fixture.MockProviderServiceBaseUri);

        // Act
        var report = await client.GetCreditReportAsync(clientId);

        // Assert
        Assert.Equal(720, report.CreditScore);
        _fixture.MockProviderService.VerifyInteractions();
    }
}
```

### Test Data Generator
[Source: docs/domains/credit-assessment/brownfield-architecture.md#Test Data]

```csharp
public class TestDataGenerator
{
    private readonly Faker<CreditAssessment> _assessmentFaker;

    public TestDataGenerator()
    {
        _assessmentFaker = new Faker<CreditAssessment>()
            .RuleFor(a => a.Id, f => Guid.NewGuid())
            .RuleFor(a => a.ClientId, f => Guid.NewGuid())
            .RuleFor(a => a.CreditScore, f => f.Random.Int(300, 850))
            .RuleFor(a => a.Decision, f => f.PickRandom("APPROVED", "REJECTED", "MANUAL_REVIEW"))
            .RuleFor(a => a.LoanAmount, f => f.Finance.Amount(10000, 500000))
            .RuleFor(a => a.LoanTerm, f => f.Random.Int(6, 60))
            .RuleFor(a => a.RiskLevel, f => f.PickRandom("LOW", "MEDIUM", "HIGH"))
            .RuleFor(a => a.CreatedAt, f => f.Date.Past(2));
    }

    public CreditAssessment GenerateAssessment() => _assessmentFaker.Generate();
    
    public List<CreditAssessment> GenerateAssessments(int count) => 
        _assessmentFaker.Generate(count);
}
```

### Integration Verification Requirements
[Source: docs/domains/credit-assessment/prd.md Story 1.17]

**IV1**: Test suite achieves >= 80% code coverage  
**IV2**: All critical business logic paths covered by tests  
**IV3**: Contract tests verify integration compatibility  
**IV4**: CI/CD pipeline runs tests on every commit

### Testing

#### Test Structure
- Unit tests: `CreditAssessmentService.Tests/Unit/`
- Integration tests: `CreditAssessmentService.Tests/Integration/`
- Contract tests: `CreditAssessmentService.Tests/Contracts/`

#### Running Tests
```bash
# Run all tests
dotnet test

# Run with coverage
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura

# Generate coverage report
reportgenerator -reports:coverage.cobertura.xml -targetdir:coverage-report
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
(To be populated by development agent)

### Debug Log References
(To be populated by development agent)

### Completion Notes List
(To be populated by development agent)

### File List
(To be populated by development agent)

## QA Results
(To be populated by QA agent)
