# Story 1.4: Message Queue Setup

## Status
Draft

## Story
**As a** system architect  
**I want** to set up RabbitMQ for reliable messaging  
**So that** microservices can communicate asynchronously

## Acceptance Criteria
1. [ ] RabbitMQ cluster configured
2. [ ] Dead letter queues for failed messages
3. [ ] Message persistence enabled
4. [ ] Monitoring and alerting setup
5. [ ] Connection pooling configured
6. [ ] Message serialization/deserialization

## Detailed Implementation Steps

### Section 1: RabbitMQ Infrastructure Setup
- [ ] Step 1: Create RabbitMQ Infrastructure Configuration
  - **Task**: Set up RabbitMQ cluster configuration with high availability, persistence, and monitoring capabilities
  - **Files**:
    - `tools/docker/rabbitmq/rabbitmq.conf`: RabbitMQ main configuration
    - `tools/docker/rabbitmq/definitions.json`: RabbitMQ definitions and policies
    - `tools/docker/rabbitmq/enabled_plugins`: Enabled plugins configuration
    - `tools/docker/rabbitmq/Dockerfile`: Custom RabbitMQ Docker image
    - `docker-compose.yml`: RabbitMQ service configuration
    - `tools/docker/rabbitmq/ssl/`: SSL certificate configuration
    - `tools/docker/rabbitmq/logs/`: Logging configuration
  - **Step Dependencies**: Story 1.1 (Monorepo setup complete)
  - **User Instructions**: Configure RabbitMQ cluster with high availability, enable persistence, set up SSL/TLS, and configure logging for production use

### Section 2: Message Queue Architecture
- [ ] Step 2: Implement Message Queue Architecture and Policies
  - **Task**: Create exchange and queue definitions, set up routing policies, and configure message durability
  - **Files**:
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/ExchangeDefinitions.cs`: Exchange definitions
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/QueueDefinitions.cs`: Queue definitions
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/RoutingDefinitions.cs`: Routing key definitions
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/MessagePolicies.cs`: Message policies
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/DeadLetterConfig.cs`: Dead letter configuration
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/RetryPolicies.cs`: Retry policies
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/MessageTypes.cs`: Message type definitions
  - **Step Dependencies**: Step 1 (RabbitMQ infrastructure)
  - **User Instructions**: Define all exchanges, queues, and routing policies for the microservices architecture, implement dead letter queues and retry policies

### Section 3: Message Serialization Framework
- [ ] Step 3: Implement Message Serialization and Deserialization
  - **Task**: Create message serialization framework with JSON support, versioning, and error handling
  - **Files**:
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/IMessageSerializer.cs`: Message serializer interface
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/JsonMessageSerializer.cs`: JSON serializer implementation
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/MessageVersioning.cs`: Message versioning support
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/SerializationOptions.cs`: Serialization options
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/MessageWrapper.cs`: Message wrapper class
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/SerializationExtensions.cs`: Serialization extensions
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/DeserializationExtensions.cs`: Deserialization extensions
  - **Step Dependencies**: Step 2 (Message queue architecture)
  - **User Instructions**: Implement robust message serialization with JSON support, versioning for backward compatibility, and proper error handling for malformed messages

### Section 4: Connection Management
- [ ] Step 4: Implement Connection Pooling and Management
  - **Task**: Set up connection pooling, connection health monitoring, and automatic reconnection
  - **Files**:
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/IConnectionManager.cs`: Connection manager interface
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/RabbitMqConnectionManager.cs`: RabbitMQ connection manager
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/ConnectionPool.cs`: Connection pool implementation
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/ConnectionHealthMonitor.cs`: Connection health monitoring
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/ReconnectionPolicy.cs`: Reconnection policy
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/ConnectionConfiguration.cs`: Connection configuration
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/ConnectionExtensions.cs`: Connection extensions
  - **Step Dependencies**: Step 3 (Message serialization)
  - **User Instructions**: Implement connection pooling with health monitoring, automatic reconnection on failures, and proper connection lifecycle management

### Section 5: Message Publishing Framework
- [ ] Step 5: Implement Message Publishing and Routing
  - **Task**: Create message publishing framework with routing, acknowledgments, and error handling
  - **Files**:
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/IMessagePublisher.cs`: Message publisher interface
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/RabbitMqMessagePublisher.cs`: RabbitMQ publisher implementation
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/PublishOptions.cs`: Publish options
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/MessageRouting.cs`: Message routing logic
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/PublishConfirmation.cs`: Publish confirmation handling
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/PublishErrorHandler.cs`: Publish error handling
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/PublisherExtensions.cs`: Publisher extensions
  - **Step Dependencies**: Step 4 (Connection management)
  - **User Instructions**: Implement reliable message publishing with routing, acknowledgments, and comprehensive error handling for failed publishes

### Section 6: Message Consumption Framework
- [ ] Step 6: Implement Message Consumption and Processing
  - **Task**: Create message consumption framework with automatic acknowledgments, error handling, and retry logic
  - **Files**:
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/IMessageConsumer.cs`: Message consumer interface
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/RabbitMqMessageConsumer.cs`: RabbitMQ consumer implementation
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/ConsumerOptions.cs`: Consumer options
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/MessageHandler.cs`: Message handler base class
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/ConsumerErrorHandler.cs`: Consumer error handling
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/RetryHandler.cs`: Retry logic implementation
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/ConsumerExtensions.cs`: Consumer extensions
  - **Step Dependencies**: Step 5 (Message publishing)
  - **User Instructions**: Implement reliable message consumption with automatic acknowledgments, error handling, and retry logic for failed message processing

### Section 7: Dead Letter Queue Management
- [ ] Step 7: Implement Dead Letter Queue and Error Handling
  - **Task**: Set up dead letter queues, implement error handling, and create message recovery mechanisms
  - **Files**:
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/IDeadLetterHandler.cs`: Dead letter handler interface
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/DeadLetterHandler.cs`: Dead letter handler implementation
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/DeadLetterQueue.cs`: Dead letter queue management
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/MessageRecovery.cs`: Message recovery mechanisms
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/ErrorClassification.cs`: Error classification
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/RetryExhaustedHandler.cs`: Retry exhausted handler
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/DeadLetterExtensions.cs`: Dead letter extensions
  - **Step Dependencies**: Step 6 (Message consumption)
  - **User Instructions**: Implement comprehensive dead letter queue management with error classification, message recovery, and retry exhausted handling

### Section 8: Monitoring and Alerting
- [ ] Step 8: Implement Monitoring and Alerting System
  - **Task**: Set up RabbitMQ monitoring, create health checks, and implement alerting for queue issues
  - **Files**:
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/IRabbitMqMonitor.cs`: RabbitMQ monitor interface
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/RabbitMqMonitor.cs`: RabbitMQ monitor implementation
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/QueueHealthCheck.cs`: Queue health check
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/MonitoringMetrics.cs`: Monitoring metrics
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/AlertingService.cs`: Alerting service
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/PerformanceMetrics.cs`: Performance metrics
    - `libs/IntelliFin.Shared.Infrastructure/Messaging/MonitoringExtensions.cs`: Monitoring extensions
  - **Step Dependencies**: Step 7 (Dead letter queue management)
  - **User Instructions**: Implement comprehensive monitoring with health checks, performance metrics, and alerting for queue issues and performance degradation

### Section 9: Integration with Microservices
- [ ] Step 9: Integrate Message Queue with All Microservices
  - **Task**: Integrate RabbitMQ with all microservices, implement service-specific message handlers, and configure inter-service communication
  - **Files**:
    - `apps/IntelliFin.ApiGateway/Services/MessageQueueService.cs`: API Gateway message service
    - `apps/IntelliFin.IdentityService/Services/MessageQueueService.cs`: Identity service message service
    - `apps/IntelliFin.ClientManagement/Services/MessageQueueService.cs`: Client management message service
    - `apps/IntelliFin.LoanOrigination/Services/MessageQueueService.cs`: Loan origination message service
    - `apps/IntelliFin.CreditBureau/Services/MessageQueueService.cs`: Credit bureau message service
    - `apps/IntelliFin.GeneralLedger/Services/MessageQueueService.cs`: General ledger message service
    - `apps/IntelliFin.PmecService/Services/MessageQueueService.cs`: PMEC service message service
    - `apps/IntelliFin.Collections/Services/MessageQueueService.cs`: Collections message service
    - `apps/IntelliFin.Communications/Services/MessageQueueService.cs`: Communications message service
    - `apps/IntelliFin.Reporting/Services/MessageQueueService.cs`: Reporting message service
  - **Step Dependencies**: Step 8 (Monitoring and alerting)
  - **User Instructions**: Integrate RabbitMQ with all microservices, implement service-specific message handlers, and configure inter-service communication patterns

### Section 10: Testing and Validation
- [ ] Step 10: Create Comprehensive Tests and Validation
  - **Task**: Create unit tests, integration tests, and end-to-end tests for the message queue system, validate all acceptance criteria
  - **Files**:
    - `libs/IntelliFin.Shared.Infrastructure.Tests/Messaging/MessageSerializerTests.cs`: Message serializer tests
    - `libs/IntelliFin.Shared.Infrastructure.Tests/Messaging/ConnectionManagerTests.cs`: Connection manager tests
    - `libs/IntelliFin.Shared.Infrastructure.Tests/Messaging/MessagePublisherTests.cs`: Message publisher tests
    - `libs/IntelliFin.Shared.Infrastructure.Tests/Messaging/MessageConsumerTests.cs`: Message consumer tests
    - `libs/IntelliFin.Shared.Infrastructure.Tests/Messaging/DeadLetterHandlerTests.cs`: Dead letter handler tests
    - `libs/IntelliFin.Shared.Infrastructure.Tests/Messaging/RabbitMqIntegrationTests.cs`: RabbitMQ integration tests
    - `libs/IntelliFin.Shared.Infrastructure.Tests/Messaging/MessageQueueE2ETests.cs`: End-to-end tests
    - `libs/IntelliFin.Shared.Infrastructure.Tests/Messaging/TestHelpers/RabbitMqTestServer.cs`: Test server helper
  - **Step Dependencies**: Step 9 (Microservices integration)
  - **User Instructions**: Create comprehensive test suite covering all message queue components, implement integration tests with real RabbitMQ, and validate all acceptance criteria are met

## Dev Notes

### Previous Story Insights
[Source: Story 1.3 - API Gateway Setup]
- API Gateway is configured with routing and middleware
- Health check endpoints are implemented
- Service discovery is set up for microservices communication

### Data Models
[Source: docs/architecture/system-architecture.md#messaging-architecture]
Message queue system will use:
- Exchange definitions for message routing
- Queue definitions for message storage
- Message types for different business events
- Dead letter queues for failed messages
- Connection pooling for performance

### API Specifications
[Source: docs/architecture/system-architecture.md#messaging-architecture]
Message queue will support:
- Inter-service communication patterns
- Event-driven architecture
- Asynchronous processing
- Message persistence and durability
- Error handling and retry logic

### Component Specifications
[Source: docs/architecture/tech-stack.md]
Message queue components:
- RabbitMQ 3.12+ for message broker
- JSON serialization for message format
- Connection pooling for performance
- Dead letter queues for error handling
- Monitoring and alerting integration

### File Locations
[Source: docs/architecture/system-architecture.md]
Message queue files should be located in:
```
lms/
├── libs/
│   └── shared/
│       └── infrastructure/        # Shared infrastructure components
│           └── messaging/         # Message queue components
├── tools/
│   └── docker/
│       └── rabbitmq/             # RabbitMQ configuration
└── apps/
    └── {service}/                # Service-specific message handlers
```

### Testing Requirements
[Source: docs/architecture/tech-stack.md]
Message queue testing standards:
- **Test Framework**: xUnit 3.0+ with RabbitMQ test containers
- **Test Location**: `libs/shared/infrastructure/tests/messaging/`
- **Coverage Requirements**: 90% for message queue components
- **Test Types**: Unit tests for components, integration tests for RabbitMQ
- **CI Integration**: All message queue tests must pass in CI pipeline

### Technical Constraints
[Source: docs/architecture/tech-stack.md]
- RabbitMQ 3.12+ with cluster configuration
- Message persistence and durability
- Dead letter queue implementation
- Connection pooling and health monitoring
- BoZ compliance for message retention
- Data sovereignty requirements (Zambian data centers)

## Testing

### Testing Standards
[Source: docs/architecture/tech-stack.md]
- **Test Framework**: xUnit 3.0+ with RabbitMQ test containers
- **Test Location**: `libs/shared/infrastructure/tests/messaging/`
- **Coverage Requirements**: 90% for message queue components
- **Test Types**: Unit tests for components, integration tests for RabbitMQ
- **CI Integration**: All message queue tests must pass in CI pipeline

### Test Scenarios
1. **Message Publishing Testing**
   - Test message publishing with routing
   - Test publish confirmations
   - Test publish error handling
   - Test message persistence
2. **Message Consumption Testing**
   - Test message consumption and processing
   - Test automatic acknowledgments
   - Test consumer error handling
   - Test retry logic
3. **Dead Letter Queue Testing**
   - Test dead letter queue functionality
   - Test message recovery mechanisms
   - Test retry exhausted handling
   - Test error classification
4. **Connection Management Testing**
   - Test connection pooling
   - Test connection health monitoring
   - Test automatic reconnection
   - Test connection lifecycle management
5. **Integration Testing**
   - Test inter-service communication
   - Test message flow between services
   - Test error propagation
   - Test performance under load

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-01-XX | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*This section will be populated by the QA agent after implementation review*
